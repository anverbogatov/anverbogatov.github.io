[{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.toml\n``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nBúsqueda de archivos adicionales Para buscar campos adicionales definidos en el front matter, debes añadirlo en 2 lugares.\nEditar layouts/_default/index.JSON Esto expone los valores en /index.json: por ejemplo, para agregar categories ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEditar las opciones de fuse.js para buscar static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.\nNo se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html\nEstablecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.\nEsta implementación utiliza Fusejs, jquery y mark.js\nConfiguración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.","tags":null,"title":"Resultados de Búsqueda"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"June 8, 2010","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"অনুসন্ধানের ফলাফল"},{"categories":null,"contents":"Пример N+1 проблемы Проще всего проблему проиллюстрировать используя классический пример с Книгой (book) и Автором (author). Предположим, что у нас в модели есть сущность Book. У каждой сущности Book есть свой Author.\nВ Java, с использованием Hibernate это отношение можно смоделировать следующим образом:\n@Data @Entity @Table(name = \u0026#34;book\u0026#34;) public class Book { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private int id; private String title; @OneToOne(fetch = FetchType.LAZY) private Author author; } ---------------------------------------------------------- @Data @Entity @Table(name = \u0026#34;author\u0026#34;) public class Author { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private int id; private String name; @OneToOne(mappedBy = \u0026#34;author\u0026#34;) private Book book; } Поле book в классе Author указывает на то, что владельцем отношения является сущность Book:\n@OneToOne(mappedBy = \u0026#34;author\u0026#34;) private Book book; Предположим, что нам необходимо загрузить из базы данных несколько книг. Для доступа к базе данных, мы используем простейший Spring Repository:\npublic interface BookRepository extends CrudRepository\u0026lt;Book, Integer\u0026gt; { } C репозиторием, подобному тому, что Я привожу выше, уже можно зачитать из базы данных все сохранённые Книги (book). Сделать это можно, просто вызвав следующий метод:\nrepository.findAll(); При наличии следующей конфигурации:\nspring: jpa: show-sql: true В логах приложения мы увидим:\nHibernate: select book0_.id as id1_1_, book0_.author_id as author_i3_1_, book0_.title as title2_1_ from book book0_ Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_ from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id=? Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_ from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id=? Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_ from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id=? Разберём подробнее, что же в мы тут видим.\nПервый запрос:\nselect book0_.id as id1_1_, book0_.author_id as author_i3_1_, book0_.title as title2_1_ from book book0_ Зачитывает все имеющиеся записи в таблице book. Для своего эксперимента Я сохранил 3 сущности типа Book. У каждой из этих сущностей, был установлен свой, уникальный автор - Author. Итого, в базе данных сохранено 3 записи в таблице book и 3 записи в таблице author.\nПосле того, как Hibernate зачитал все имеющиеся книги одним запросом, он начал зачитывать записи из таблицы с авторами по одному, с использованием outer join конструкции.\nЭто и есть проблема - N+1.\nЧто такое N+1? Проблема N+1 - это проблема неоптимального доступа к сохранённым данным, при которой каждой из записей зачитанных одним sql запросом связные данные будут зачитаны по одному.\nN+1 можно так же расшифровать как - один запрос, чтобы зачитать множество сущностей одного типа, но N запросов, чтобы зачитать все связные сущности.\nПочему это происходит? Потому что, в момент когда мы используем репозиторий для загрузки всех сущностей типа Book, мы не сообщаем о том, что нам так же нужны связные сущности типа Author.\nЗапрос за каждой связной сущностью Author происходит в момент доступа к ней, через поле author объектов типа Book.\nКак обойти проблему? Обойти проблему можно используя нативную фичу Hibernate под названием «Batch Fetching» (пакетная выборка).\nДостаточно добавить следующую аннотацию на объявление класса сущности Author:\n@BatchSize(size = 100) И запросы в логах будут выглядеть следующим образом:\nHibernate: select book0_.id as id1_1_, book0_.author_id as author_i3_1_, book0_.title as title2_1_ from book book0_ Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_ from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id in (?, ?, ?) Первый запрос зачитает все записи из таблицы book, а второй запрос зачитает все связные записи из таблицы author.\nПолезные материалы  [1] GitHub - anverbogatov/hibernate-n1-problem: This repository contains simple Spring Boot application that is intended to illustrate N+1 problem in Hibernate. - полный код приложения, которое Я написал, чтобы продемонстрировать проблему [2] HIBERNATE - Relational Persistence for Idiomatic Java - документация о пакетной выборке данных в Hibernate  ","date":"November 10, 2021","hero":"/images/default-hero.jpg","permalink":"/posts/technologies/content/hibernate-n1-problem/","summary":"Пример N+1 проблемы Проще всего проблему проиллюстрировать используя классический пример с Книгой (book) и Автором (author). Предположим, что у нас в модели есть сущность Book. У каждой сущности Book есть свой Author.\nВ Java, с использованием Hibernate это отношение можно смоделировать следующим образом:\n@Data @Entity @Table(name = \u0026#34;book\u0026#34;) public class Book { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private int id; private String title; @OneToOne(fetch = FetchType.LAZY) private Author author; } ---------------------------------------------------------- @Data @Entity @Table(name = \u0026#34;author\u0026#34;) public class Author { @Id @GeneratedValue(strategy = GenerationType.","tags":["hibernate"],"title":"🇷🇺 Hibernate N+1 Проблема"},{"categories":null,"contents":"Что такое Risk Storming? Это метод, позволяющий легко и быстро, коллективно и визуально идентифицировать риски в системе. Метод подразумевает участие нескольких людей. Для более широкого взгляда на рассматриваемую систему, полный состав участников может включать в себя людей из разных направлений и с разными навыками.\nМетод Сам метод состоит из нескольких последовательно выполняемых шагов. Разберём каждый их них.\nШаг 1: Нарисовать диаграммы архитектуры Поскольку метод подразумевает поиск рисков в готовой или строящейся системе, нам необходимо эту самую систему каким-то образом видеть.\nРисунок 1. Пример risk storming сессии\nДиаграммы архитектуры в этом плане - прекрасное подспорье. Они проиллюстрируют основные компоненты системы и их взаимосвязи.\nШаг 2. Индивидуальный поиск рисков На данном шаге, каждый из участников выписывает абсолютно любые риски и проблемы, пришедшие ему в голову, на стикеры.\nЭтот шаг проводится в абсолютной тишине и должен быть ограничен по времени. Например, 5-10 минут может быть вполне достаточно.\nПримерами рисков могут быть абсолютно любые предположения о неработоспособности чего-либо. Например:\n Формат данных в сторонней системе изменился Внешние сервисы недоступны Неконсистентость данных  Шаг 3. Делимся предположениями На данном шаге, все участники сессии размещают свои стикеры на диаграммах архитектуры, на основе которых производился поиск рисков.\nСтикеры размещаются близкой к той части диаграммы, к которой относится описанные риски.\nЕсли несколько участников сессии описали схожие риски, стикеры этих рисков располагаются вместе.\nРисунок 2. Риски и архитектура\nШаг 4. Приоритизация И на заключительном шаге, каждый из найденных рисков, рассматривается и обсуждается коллективно.\nЗадача этого шага определить насколько высокий приоритет имеет найденная потенциальная проблема.\nВариантов оценить приоритет несколько. Я опишу их два:\n Planning Poker (PlanningPoker.com - Estimates Made Easy. Sprints Made Simple.) - это когда участники оценивают риски, используя карты с цифрами и коллективно обсуждая. В конце концов, переговоры должны придти к общему пониманию. Используя специальную матрицу, на которой на одной оси располагается Вероятность возникновения проблемы, а на другой - её Влияние. Рисунок 3. Матрица оценки риска  Пример Для того, чтобы посмотреть на метод в действии, нам понадобится архитектурная схема системы. Поскольку подход абсолютно универсальный - я взял произвольную схему из Интернета: Рисунок 4. Схема работы сервиса\nТеперь, когда у нас есть схема архитектуры мы можем приступать.\nСледующим шагом будет попытка каждого участника идентифицировать риски, возможные в абсолютно любой части системы. Риски описываются на стикерах и затем, стикеры, располагаются на той части схемы, к которой риск, описанный на нём, относится.\nУ меня получилось следующее: Рисунок 5. Отмеченные риски\nНапомню, что цель данного метода не вычислить каждый возможный потенциальный риск. Естественно, должны быть пределы разумного. «Нападение акул на сотрудников дата центра» - хорошая идея, но это гарантированно не произойдёт (если только дата центр не располагается на дне океана).\nСледующим шагом будет коллективная оценка каждого найденного риска, с помощью принятого в команде метода оценки. Для примера я воспользуюсь методом с матрицей. Давайте попробуем оценить приоритет риска с загрузкой в наш сервис гигантского файла (нужно прояснить, под гигантским файлом я имею ввиду любой контент, размер которого выходит за пределы разумного и принятого для данной системы).\nЗагрузка гигантского файла может заставить нашу систему расходовать большое количество ресурсов на его обработку и хранение. Более того, предположим что наш Image Storage, это S3 сервис от AWS, а это значит что хранение гигантских объёмов данных будет стоить нам больших денег. Поэтому я полагаю, что Вероятность, что кто-то попробует это провернуть не нулевая, так что Medium, а Влияние на работоспособность системы и её обслуживание велико, то есть High. Оценив риск таким образом, я поместил его в соответствующую строку и колонку. Рисунок 6. Оценка одного из рисков\nАналогично, нужно поступить и с каждым из оставшихся рисков. В итоге, мы получим примерно следующую картину: Рисунок 7. Итоговая оценка рисков\nИтак, мы получили оценки для каждого из рисков. С матрицей уже сейчас можно сделать выводы о том, какие из рисков нужно постараться обработать быстрее остальных. Например, неограниченное количество запросов к сервису может привести к полному отказу работоспособности сервиса из-за DDOS атаки.\nСписок рисков с их оценкой в дальнейшем послужит отличной вводной информацией для формирования технического бэклога команды, обслуживающей сервис.\nДополнительные материалы  [1] Risk-storming - веб-сайт методологии [2] https://leanpub.com/software-architecture-for-developers - книга автора методологии. В самой книге, методологии посвящена небольшая глава.  ","date":"October 30, 2021","hero":"/images/default-hero.jpg","permalink":"/posts/modeling/content/risk-storming/","summary":"Что такое Risk Storming? Это метод, позволяющий легко и быстро, коллективно и визуально идентифицировать риски в системе. Метод подразумевает участие нескольких людей. Для более широкого взгляда на рассматриваемую систему, полный состав участников может включать в себя людей из разных направлений и с разными навыками.\nМетод Сам метод состоит из нескольких последовательно выполняемых шагов. Разберём каждый их них.\nШаг 1: Нарисовать диаграммы архитектуры Поскольку метод подразумевает поиск рисков в готовой или строящейся системе, нам необходимо эту самую систему каким-то образом видеть.","tags":["modeling","risk-storming"],"title":"🇷🇺 Метод идентификации рисков Risk Storming"},{"categories":null,"contents":"Что такое User Story Mapping? User Story Mapping или КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ - это способ визуального планирования и приоритизации задач. Способ хорош тем, что заставляет нас думать о своих software решениях с позиции ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ (User Story).\nПрежде чем мы перейдём к знакомству с методом, важно разобраться с тем, а что такое вообще ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ.\nЧто такое User Story? ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ - это описание какой-либо фичи продукта, рассказанное с точки зрения её пользователя. Буквально рассказ о том, как именно фича используется конкретным пользователем. ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ при описании функционала software продукта, ставят во главу угла именно пользователя.\nПри написании ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ зачастую используется следующая схема:\nAs a [type of user], I want [some particular feature], So that [some benefit] is received. На русском, эта схема будет выглядеть следующим образом:\nКак [тип пользователя], Я хочу [описание какого-то действия], Чтобы [описание цели]. При составлении ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ важно понимать какой уровень детализации Вам необходим. Например, следующая история это плохой пример:\nКак клиент онлайн магазина, Я хочу купить товар, Чтобы им пользоваться. Почему это пример плох? Давайте закроем глаза на то, что пример взял из головы и описание цели странноватое. Главная проблема этого примера в том, что «хочу купить товар» это слишком большое действие, чтобы описывать его одной историей. «Купить товар» обычно подразумевает:\n открыть сайт онлайн магазина найти нужный товар просмотреть его характеристики прочитать отзывы на него добавить его в корзину залогиниться для сохранения истории покупок ввести данные банковской карты оплатить  Почему важно подобрать удобный уровень детализации ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ? Потому что основная польза метода КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ заключается в планировании доставки функционала небольшими частями. Это позволяет от одного небольшого релиза к другому, этакими частыми шажками, придти к конечной цели пользователя, реализованной в виде software решения.\nОгромные истории крайне трудно планировать, поскольку, из-за своего размера они сразу займут много времени и частичную их доставку запланировать будет проблематично. Поэтому хорошей практикой будет разбивать большие задачи, на отдельные истории. Выше я уже привёл список действий, которые входят в состав действия «Купить товар». Каждое их этих мелких действий будет отдельной историей.\nКак выглядит User Story Mapping? Итак, теперь, когда мы разобрались с тем, что такое ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ, самое время разобраться с методологией, которая их активно использует.\nИтак, попробуем составить свою КАРТУ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ. И для этого, в первую очередь нужно понять какую именно фичу мы будем моделировать. Раз уж мы заговорили про покупку товара в онлайн магазине, давайте продолжим этот пример.\nКАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ, это метод визуального моделирования и планирования, поэтому для визуализации моей истории, я буду использовать сервис Miro (Online Whiteboard \u0026amp; Visual Collaboration Platform | Miro).\nИстория состоит из нескольких шагов, выполняемых пользователем в определённой последовательности. Поэтому на нашу электронную доску, первым делом мы добавим нашего пользователя.\nДля чего это нужно? Как уже было сказано выше, ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ - это ориентированный на пользователя (user-centric) подход. Поэтому при моделировании историй, нужно всегда держать в голове от лица кого эта история рассказывается.\nКаркас Далее, для того чтобы наша история стала похожа на осмысленный нарратив, нам нужно рассказать что и в какой последовательности делает наш пользователь. Для этого, основные действия в истории пользователя мы добавим в виде отдельных стикеров и расположим их в порядке их выполнения, слева-направо.\nУ нас получился список мелких целей, которые пользователь пытается достичь на каждом этапе. Если мы попытаемся рассказать историю, нарратив, используя эти карточки в качестве подсказок, то у нас это легко получиться. Это будет история про то, как Клиент онлайн магазина заказывает товар. В этом и есть ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ. Однако, КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ на этом не заканчивается.\nТо, что мы только что сделали, этот набор стикеров, из которых состоит наша история, называется КАРКАС (или Backbone, в зарубежной литературе). Именно он является основой ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ, и именно на него мы будем наслаивать остальные элементы, а именно генерировать мелкие истории в формате задач, а так же выделять части чего-то единого.\nСледующим шагом, давайте посмотрим на оранжевые стикеры. Несмотря на то, что каждый из них описывает свой уникальный шаг пользователя на пути к конечной цели, есть в них и общие элементы. Например, «Ввести данные банковской карты» и «Произвести оплату заказа» относятся к более крупному действию, а именно - «Оплата товара».\nЕщё один нюанс, о котором я сразу хочу упомянуть - КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ должен являться живым документом. Его содержимое должно обсуждаться, меняться и поддерживаться в актуальном состоянии. Это абсолютно нормально, работать над ним итеративно, меняя его содержимое и порядок операций для того, чтобы отразить видение того, как именно должен пройти путь пользователя через наше software решение, прежде, чем он достигнет конечного результата.\nИтак, после очередной итерации, наша карта стала выглядеть следующим образом:\nВнимательный читатель заметит, что на карте появились голубые стикеры, которые отображают более общие шаги и называются АКТИВНОСТЯМИ, а так же, поменялся порядок некоторых оранжевых стикеров.\nНо и это ещё не всё. Пока мы просто организуем наше представление о действиях пользователя. Мы прописываем саму историю. Однако, поскольку КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ является ещё и инструментом планирования задач, самое время про это и поговорить.\nЗадачи Каждый из оранжевых стикеров описывает большой шаг на пути к конечной цели. Более того, каждый из них может содержать в себе несколько под-шагов или даже различных вариантов одного и того же действия.\nЭти под-шаги или варианты, в данном методе называются ЗАДАЧАМИ и отображаются в вертикальной оси, снизу от КАРКАСА, с помощью стикеров другого цвета.\nКаждая ЗАДАЧА относится к своему элементу КАРКАСА, и описывает какое-то небольшое действие, целью которого является как раз таки, элемент КАРКАСА. Если совсем просто, стикеры с задачами, размещаются под оранжевыми стикерами, к которым они имеют отношение. Каждый из стикеров-задач, является ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИЕЙ, которая может быть передана разработчику.\nВ случае с моей картой, стикеры-задачи могут выглядеть так:\nЕсть один простой трюк, который поможет описывать задачи так, чтобы:\n все они имели схожую смысловую структуру и, чтобы все участники моделирования, предельно точно понимали что и зачем нужно делать. Именно из ЗАДАЧ, в последствии будут созданы тикеты для разработчика.  Итак, трюк следующий - помните схему, по которой составляются ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ: As a [user], I want [something], So that [achieve some benefit] А теперь немного изменим её, заменив общие термины на элементы карты:\nAs a [user], I want [task], So that [backbone element] Моя схема написана на русском, так что, давайте, следуя этой схеме, попробуем составить несколько историй для разработчика:\n1) Как клиент онлайн магазина, Я хочу использовать строку поиска, Чтобы найти нужный товар 2) Как клиент онлайн магазина, Я хочу использовать номер телефона, Чтобы залогиниться в системе 3) Как клиент онлайн магазина, Я хочу просмотреть описание товара, Чтобы посмотреть информацию о товаре Каждая из ЗАДАЧ, в подобном написании, представляет из себя ПОЛЬЗОВАТЕЛЬСКУЮ ИСТОРИЮ. В таком случае, каждый из оранжевых стикеров - представляет из себя Epic (то есть, большую задачу, которая состоит из ряда историй). Если уж совсем точно, то - оранжевые тикеты, это Epic’и в JIRA, тикеты-задачи - это User Story в JIRA. Каждая из User Story в JIRA, затем может быть разбита на несколько тикетов, в рамках которых разработчик реализует те или иные части фичи.\nПланирование Пришло время поговорить о последнем элементе КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ, а именно о планировании.\nЕсли горизонтальная плоскость отображает шкалу времени, то вертикальная в данном методе, отображает приоритет. Чем выше ЗАДАЧА в колонке, тем выше и её приоритет и, соответсвенно, она быстрее будет выполнена разработчиком.\nЕсть два способа планирования в данном методе. Блок с ЗАДАЧАМИ может быть поделён, с помощью горизонтальных линий на:\n важность или релизы  В случае с важностью, обычно используют три уровня: Must, Should, Could. Первый означает первоочерёдную ценность задач и означает, что они обязаны быть выполнены. Второй - что задачи важны и хорошо бы их выполнить. Третий - необязательны и могут быть не выполнены. Пример деления по важности выглядит следующим образом:\nКак можно увидеть на скриншоте выше, мы просто разделили набор ЗАДАЧ на блоки, относительно их важности.\nВторой способ, вместо важности - разделение на релизы. Выглядит следующим образом:\nКак можно заметить, выглядит это примерно так же, как и вариант выше, однако, насчёт привязки к номеру версии software решения, мы можем планировать ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ к выпуску в определённых версиях нашего софта.\nПроцесс моделирования В заключение, расскажу о том как, по мнению автора методологии, должен проходить процесс моделирования карт.\nПрежде всего, подобные карты создаются не одним человеком, а группой людей, включающей себя бизнес-ориентированных людей (Product Owner’а например), заинтересованных в фиче людей и разработчиков. Моделирование карты происходит в формате воркшопа, то есть - живого общения с обсуждениями и разноцветными стикерами на флипчартах и стенах.\nОсновных шагов в ходе воркшопа пять:\n Определение скоупа. На данном этапе все участники сессии моделирования карты должны иметь единое понимание того, о чём будет идти речь. Пользователи и фичи, для которых будет производиться моделирование, должны быть оговорены заранее. Создание большой картины. На этом этапе накидываются основные идеи о составе истории. Происходит первоначальное создание каркаса фичи. Детализация. На данном этапе через коллективное обсуждение элементы каркаса разбиваются на более мелкие задачи. Пересматриваются элементы каркаса, меняются местами, добавляются новые, удаляются ненужные, выделяются активности. Разделение на релизы. На этом этапе задачи группируются на релизы. Каждый релиз фактически представляет из себя небольшой MVP. Каждый релиз должен иметь описание ценности, которую он доставит и описание метрик, с помощью которых можно будет замерить достижение цели релиза. Стратегия разработки и релизов. На этом этапе уже планируются задачи в разработку. Если нужно, карта актуализируется ещё. Цель этого этапа связать планирование на карте непосредственно с разработкой фичи.  Словарь терминов  КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ - она же User Story Mapping; метод визуального описания и планирования задач. ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ - она же User Story; это способ описания взаимодействия пользователя с software системой в формате нарративного повествования. КАРКАС - он же Backbone; основной набор шагов ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ. АКТИВНОСТИ - это группа задач, имеющих схожие цели.  Дополнительные материалы  [1] https://www.jpattonassociates.com/wp-content/uploads/2015/03/story_mapping.pdf Отличный pdf документ-памятка по рассматриваему сегодня методу [2] Книга «Пользовательские истории. Искусство гибкой разработки ПО» Паттон Джефф – купить книгу ISBN 978-5-496-02931-5 с быстрой доставкой в интернет-магазине OZON  ","date":"October 25, 2021","hero":"/images/default-hero.jpg","permalink":"/posts/modeling/content/user-story-mapping/","summary":"Что такое User Story Mapping? User Story Mapping или КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ - это способ визуального планирования и приоритизации задач. Способ хорош тем, что заставляет нас думать о своих software решениях с позиции ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ (User Story).\nПрежде чем мы перейдём к знакомству с методом, важно разобраться с тем, а что такое вообще ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ.\nЧто такое User Story? ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ - это описание какой-либо фичи продукта, рассказанное с точки зрения её пользователя.","tags":["design","usecase","userstory","userstorymapping"],"title":"🇷🇺 User Story Mapping или Карты Пользовательских Сценариев"},{"categories":null,"contents":"Введение Для того, чтобы разобраться с темой, нам понадобятся два понятия:\nСЦЕНАРИЙ - это последовательность шагов, совершаемых в определённых условиях, с целью достижения определённой цели, и, оканчивающаяся результатом, который напрямую связан с целью. Эта последовательность начинается с действия, которое является триггером (причиной для начала), и продолжается до тех пор, пока не будет достигнута или провалена конечная цель.\nПРЕЦЕДЕНТ - это набор сценариев взаимодействия между системой и актёрами; отображает как именно цель основного актёра может быть достигнута или провалена. Например, прецедент оформления возмещения страховой выплаты в результате происшествия, будет включать в себя оба сценария - «успешная выплата» и «выплата невозможна из-за нарушения правил».\nЕсли быть совсем точным, то в состав одного ПРЕЦЕДЕНТА, могут войти один и более СЦЕНАРИЕВ.\nСЦЕНАРИИ, в свою очередь, могут быть двух видов:\n Основными и Альтернативными  Основной СЦЕНАРИЙ - это сценарий, описывающий успешное достижение конечной цели главным актёром.\nАльтернативный СЦЕНАРИЙ - это сценарий, описывающий безуспешное достижение конечной цели главынм актёром, или же последовательность шагов, позволяющую достичь своей цели, после её провала.\nПримеры Скорее всего, описание Вам покажется неясным. Особенно, описание Альтернативного СЦЕНАРИЯ, однако, всё встанет на свои места, как только мы разберёмся с примером.\nПредставьте, что мы составляем ПРЕЦЕДЕНТ, в котором Клиент (основной актёр) резервирует столики в системе обслуживания ресторана. Примером основного СЦЕНАРИЯ, в таком случае может быть следующий сценарий:\n Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время Администратор проверяет наличие столика и подтверждает резерв  В этом случае, цель пользователя достигнута полностью - клиент получил столик в распоряжение в оговорённое время.\nАльтернативный СЦЕНАРИЙ, в котором цель основного актёра будет провалена, может выглядеть следующим образом:\n Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время Администратор проверяет наличие столика и сообщает Клиенту о том, что в наличии свободного столика на оговорённую дату не имеется  Ну и наконец, альтернативный СЦЕНАРИЙ, в котором цель основного актёра будет достигнута после её первоначального провала будет выглядеть так:\n Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время Администратор проверяет наличие столика и сообщает Клиенту о том, что в наличии свободного столика на оговорённую дату не имеется Администратор проверяет наличие столика на время ближайшее к оговорённому ранее и предлагает эту дату и время Клиенту Клиент подтверждает своё согласие на новую дату и время Администратор подтверждает резерв  Уровни детализации В своей работе под названием \u0026ldquo;Structuring Use cases with goals\u0026rdquo;, Алистер Кокбёрн, вводит понятие уровня моря, как \u0026ldquo;золотое сечение\u0026rdquo; степени детализации ПРЕЦЕДЕНТА и СЦЕНАРИЯ. Переводится это буквально - sea level (на следующем изображении, он подписан как \u0026ldquo;User Goal Level\u0026rdquo;).\nЕсли внимательно посмотреть на изображение выше, можно увидеть, три больших уровня. На двух из них, существуют подуровни. Перечислим их:\n Summary Level - можно перевести как \u0026ldquo;Уровень обобщения\u0026rdquo;. Он имеет два подуровня:  Cloud Level - буквально - \u0026ldquo;Уровень небес\u0026rdquo; Kite Level - \u0026ldquo;Уровень кайта\u0026rdquo;. Аналогии с предметами из жизни в данной модели приведены неспроста. Запущенный в небо кайт, летает ниже уровня облаков.   Sea Level (User Goal Level) - \u0026ldquo;Уровень моря\u0026rdquo;. Subfunctions Level  Fish / Indigo Level Clam / Black Level    Давайте поговорим о каждом из них.\nSummary Level Summary Level или Уровень обобщения - это уровень на котором процессы видны в контексте их жизненного цикла. Что это значит, это значит что уровень деталей настолько мал, что мы можем изображать процесс, который в жизни занимает многие дни и даже годы. Каждый шаг на данном уровне имеют свою уникальную конечную цель и может быть представлен в деталях на Уровне моря.\nКокбёрн выделяет два подуровня на Уровне обобщения:\nCloud Level Уровень небес отображает процессы с наименьшим количеством деталей. ПРЕЦЕДЕНТОВ, описываемых на данном уровне может быть крайне мало, буквально, 5-6 на всю организацию. Примерами могут быть: реклама товаров, продажа товаров потребителям, управление ресурсами и т.д.\nKite Level Уровень кайта показывает обобщённые ПРЕЦЕДЕНТЫ. Сами же ПРЕЦЕДЕНТЫ на этом уровне изображаются на уровне департаментов, но продолжают отображать обобщённые цели. Примерами могут быть: регистрация пассажира на рейс, оформление билета на рейс.\nSea Level (User Goal Level) На Уровне моря бизнес-процессы описываются уже более детализированно, чем на уровнях выше. Сам Кокбёрн рекомендует задавать следующие вопросы при разработке ПРЕЦЕДЕНТОВ и их СЦЕНАРИЕВ с этим уровнем детализации - \u0026ldquo;Может ли основной актёр уйти удовлетворённым после выполнения этого процесса? Достиг ли основной актёр своей конечной цели?\u0026rdquo;. Примерами могут быть: добавление товара в корзину, оформление заказа и т.д.\nВсё, что проектируется с уровнем детализации ниже Уровня моря скорее относится к системному дизайну, нежели к бизнес проектированию.\nSubfunctions Level Ниже Уровня моря лежат мелкие детали. Зачастую, люди из бизнеса не слишком заинтересованы в подобной детализации процессов, однако, людям из разработки подобный уровень детализации позволяет получить больше информации о технических аспектах реализации процесса.\nКокбёрн выделяет следующие два под уровня:\nFish / Indigo Level Примерами могут быть: поиск кода аэропорта определённого города, отображение списка клиентов, после ввода имени и т.д.\nClam / Black Level Это самый низкий уровень с наибольшим количеством деталей. Подобная детализация может оказаться излишней даже для людей из разработки. Примерами могут быть: валидация введённых в поле данных, добавление нового поля в форму и т.д.\nПример с картой Нужны ли все эти уровне в описании бизнес-процессов? Думаю, что нет. Однако, здорово иметь подобную свободу, ведь, каждый может выбрать способ описания ПРЕЦЕДЕНТОВ и СЦЕНАРИЕВ, подходящий конкретно ему.\nВ любом случае, если после описания выше Вам всё ещё затруднительно разобраться, что это всё означает, я приведу пример с картой, который напрямую отображает некоторые уровни детализации.\nИтак, предположим, что у нас есть ПРЕЦЕДЕНТ - \u0026ldquo;Добраться из Самары в Москву\u0026rdquo;. Процесс перемещения из одного города в другой можно описать разными предложениями, с указанием разных деталей. Визуально, маршрут легко представить с помощью карты:\nКак не сложно догадаться, все три картинки, отображают части маршрута от Самары до Москвы с разным удалением от уровня земли. Чем ближе к поверхности земли, тем больше деталей нам доступно.\nКарта #1 показывает весь маршрут с высоты Уровня небес. Глядя на маршрут с такой высоты мы можем описать его только фразами вида: \u0026ldquo;Выезжаем из Самарской области в сторону Пензы. Проезжаем Пензу и направляемся в сторону Рязани\u0026rdquo;. В жизни, перемещения на такие расстояния займут много часов.\nКарта #2 показывает участок маршрута на Уровне моря. Карта на этом уровне детализации содержит большее количество деталей. Маршрут на таком уровне детализации может быть описан примерно такими СЦЕНАРИЯМИ: \u0026ldquo;Выезжаем через северный выезд из города Самара и едем через посёлок Пребрежный в сторону Жигулёвска\u0026rdquo;. То есть, уровень детализации такой, что мы описываем перемещение между городами и сёлами в пределах одной области. Напомню, в случае с Уровнем небес, мы описывали перемещения между областями и большими городами.\nКарта #3 уже находится на Уровне Рыб (fish level), а значит содержит множество мелких деталей о маршруте. Если взглянуть на карту, можно увидеть маршрут с высокой детализацией - можно рассмотреть по каким именно улицам и дорогам нужно двигаться, где именно поворачивать, и т.д.\nСферы применения Напоследок, хочется порассуждать, а где же эти знания могут пригодиться?\nДействительно, разработчики в своей ежедневной практике практически не сталкиваются с разработкой ПРЕЦЕДЕНТОВ и бизнес требований, однако, всё же, это не значит, что навыки описания ПРЕЦЕДЕНТОВ с нужным уровнем детализации будут бесполезны.\nНа мой взгляд, есть две сферы применения этих навыков в жизни разработчика:\n Это разработка и управление командой. В случае с разработкой, эти навыки позволяют правильно воспринимать требования их ПРЕЦЕДЕНТОВ, переданных в разработку. Сопоставляя конечную цель основного актёра и СЦЕНАРИИ, входящие в состав ПРЕЦЕДЕНТОВ, разработчик может как лучше понять детали будущей реализации системы, так и увидеть белые пятна в предложенных СЦЕНАРИЯХ (недостаток деталей). Это проектирование. Такие подходы к проектированию, как Domain Storytelling сильно завязаны на понятия СЦЕНАРИЯ и уровней детализации. Наличие навыка составления граммотных ПРЕЦЕДЕНТОВ и СЦЕНАРИЕВ играет ключевую роль в проектировании domain stories в подходе.  Словарь терминов  СЦЕНАРИЙ - он же scenario, он же user story. ПРЕЦЕДЕНТ - он же use case или сценарий использования.  Дополнительные материалы  [1] Книга Алистера Кокбёрна \u0026ldquo;Writing Effective Use Cases\u0026rdquo; https://www.ozon.ru/product/writing-effective-use-cases-1829617/?sh=jD1ziFN8 [2] Методичка Алистера Кокбёрна \u0026ldquo;Structuring Use cases with goals\u0026rdquo; https://www.researchgate.net/publication/2807676_Structuring_Use_cases_with_goals [3] Статья \u0026ldquo;Use Case Modelling\u0026rdquo; https://www.w3computing.com/systemsanalysis/use-case-modeling/  ","date":"October 19, 2021","hero":"/images/default-hero.jpg","permalink":"/posts/soft-skills/content/use-case-goal-levels/","summary":"Введение Для того, чтобы разобраться с темой, нам понадобятся два понятия:\nСЦЕНАРИЙ - это последовательность шагов, совершаемых в определённых условиях, с целью достижения определённой цели, и, оканчивающаяся результатом, который напрямую связан с целью. Эта последовательность начинается с действия, которое является триггером (причиной для начала), и продолжается до тех пор, пока не будет достигнута или провалена конечная цель.\nПРЕЦЕДЕНТ - это набор сценариев взаимодействия между системой и актёрами; отображает как именно цель основного актёра может быть достигнута или провалена.","tags":["design","usecase"],"title":"🇷🇺 Уровни детализации Use Case'ов"},{"categories":null,"contents":"Зачем про это знать? Изначально техники построения речи возникли в качестве подспорья людям, проходящим интервью. А конкретно, такие техники широко используются для ответа на вопросы поведенческого характера, например - \u0026ldquo;Вспомните себя в ситуации Х, что вы делали, как справились?\u0026rdquo;\nВ этой статье, речь пойдёт как раз таки об одной из таких техник.\nОписание STAR - это аббревиатура, где каждая буква означает определённый подраздел в изложении Вашего ответа.\nВ каждом таком подразделе следует описать определённую вещь:\n Situation: опишите ситуацию в которой Вы были или задачу, над которой Вы работали Task: опишите какую цель Вы пытались достичь Action: опишите действия, которые вы предприняли, чтобы справиться с задачей с достаточным уровнем детализации, но сохраняя фокус повествования на Вас. Конкретно какие шаги Вы предприняли? Каков конкретно Ваш вклад? Будьте крайне внимательны к собственному повествованию. Это рассказ не о достижениях команды, а о Ваших личных. Не стоит рассказывать, говоря «мы», стоит рассказывать только с «Я» Result: опишите результат Ваших действий. Чем всё закончилось? Чего Вы достигли? Что Вы выучили или вынесли для себя?  Пример С моей стороны, примером повествования с использованием этой техники, был бы следующий рассказ:\n\u0026ldquo;Однажды, на одном из собеседований меня спросили про Х. Вопрос мне был предельно понятен, но что ответить, и самое главное, как это сделать граммотно - я не придумал. Поэтому для себя я чётко решил - нужно найти способ ответов на подобные вопросы. После долгих поисков, я выяснил, что существует целая область техник построения речи, которая может помочь в решении моей проблемы. Я начал читать про разные техники, выбрал одну для досконального изучения и в конце концов, научился граммотно отвечать на вопросы, подобные тому, что задали мне на собеседовании. Даже статью написал на эту тему.\u0026rdquo;\nРазберём подробнее:\n S - situation - на собеседовании задали вопрос, на который не смог ответить T - task - найти способ отвечать на подобные вопросы A - action - узнал про техники построения речи, изучил одну из них R - result - научился пользоваться выбранной техникой, написал статью о ней  Памятка Заключение В качестве заключения, от себя скажу - техники подобные этим, здорово помогают выстраивать свою речь, свои рассказы, в легко воспринимаемую цепочку предложений. Если Вы когда-либо находили себя в ситуации, когда Вам трудно что-либо объяснить собеседнику, техники, подобные этим, станут прекрасным подспорьем в преодолении подобных проблем.\n","date":"October 8, 2021","hero":"/images/default-hero.jpg","permalink":"/posts/soft-skills/content/star-technique/","summary":"Зачем про это знать? Изначально техники построения речи возникли в качестве подспорья людям, проходящим интервью. А конкретно, такие техники широко используются для ответа на вопросы поведенческого характера, например - \u0026ldquo;Вспомните себя в ситуации Х, что вы делали, как справились?\u0026rdquo;\nВ этой статье, речь пойдёт как раз таки об одной из таких техник.\nОписание STAR - это аббревиатура, где каждая буква означает определённый подраздел в изложении Вашего ответа.\nВ каждом таком подразделе следует описать определённую вещь:","tags":["softskills","skills"],"title":"🇷🇺 STAR Technique"},{"categories":null,"contents":"Что такое Problem Solving? Это умение решать проблемы. Всё, расходимся. 😁\nПошутили?! Давай разбираться! Это действительно умение решать проблемы, но что такое «решать проблемы»? Как это «решать проблемы»? Да и что такое «проблема» вообще?\nЧто такое «Проблема»? Под «проблемой» в IT понимается любая задача или ситуация решение которой требуется найти. Для разработчика такой «проблемой» может стать очередная задача, выданная ему менеджером или же алгоритмическая задача, данная ему на собеседовании.\nПростые проблемы не рассматриваются в рамках Problem Solving Skill темы. Для неё представляют интерес проблемы, которые не имеют ясного решения и его, решение, как раз таки требуется найти.\nЧто такое «Решать проблемы»? «Решать проблемы» можно надеясь на интуицию, или пытаясь подобрать подходящие решения, а может быть мы уже видели / знаем как решались подобные задачи и можем решить их сейчас.\nНа самом деле, у процесса решения любой проблемы есть строгий алгоритм.\nАлгоритм Интеллект-карта выше иллюстрирует шаги и подшаги, относящиеся к процессу решения проблемы. Всего четыре шага, и один из шагов имеет два подшага. Давай подробно их разберём.\nUnderstand the problem Всё начинается с «Понимания проблемы». Прежде чем приступить к поиску решения, нужно чётко понимать, что поставленная задача предельно ясна. Не стоит сломя голову бросаться в Google или «омут» и штурмовать задачу нахрапом.\nВзгляни на требования, если есть неясности или сомнения - смело задавай проясняющие вопросы. Помни - кристально ясная задача - это наполовину решенная задача.\nDevise the plan После выяснения всех необходимых деталей и прояснения нюансов, наступает шаг «Разработки плана». Как бы официально название шага не звучало, это именно тот этап, на котором мы отвечаем сами себе на вопрос - а как, собственно, мы будем задачу решать?\nУ данного этапа есть два подшага.\nResearch for an existing solution На этом этапе выполняется поиск существующего решения проблемы. Google, Stackoverflow и прочие информационные ресурсы в помощь. Задача этого этапа ответить на вопрос - какие известные решения могут нам помочь?\nAdapt it to our specific case На этом этапе происходит более детальный анализ применимости существующих решений для решения текущей задачи. Главная задача этого этапа ответить на вопрос «Насколько подходит то или иное решение конкретно нашей задаче?».\nImplement the solution Наконец, самый главный этап - это разработка решения задачи. На этом этапе уже требуется претворить план, разработанный на предыдущих этапах, в жизнь.\nVerify the results Последний этап не менее важен, чем предыдущий. После реализации задуманного плана, необходимо, удостовериться, что решение, которое мы создали, действительно, полностью решает поставленную задачу.\nЕсли решение оценивается как неудовлетворительное, то это признак того, что на одном из предыдущих этапов была допущена ошибка - либо задача была понята не полностью, либо выбран не верный подход. В таком случае, алгоритм хорош тем, что можно просто вернуться в его начало, и пройти по этапам ещё раз.\nПример Довольно часто на собеседованиях на роль программиста дают алгоритмические задачи и, опять же, довольно часто, задача выглядит так:\nНапишите функцию расчёта чисел Фибоначчи. Количество чисел должно быть передано в функцию как целое число. Попробуем решить её, используя алгоритм, описанный выше.\n Чтобы полностью понять нужно задать ряд уточняющих вопросов:  Что такое числа Фибоначчи? (Если не помним или не знаем, лучше сразу уточнить у интервьюера. В конце концов, вместо числе Фибоначчи в задаче может быть всё что угодно и совсем не обязательно известное заранее) Могут ли быть отрицательные целые числа переданы в качестве аргумента? В задаче об этом ни слова, а значит, потенциально наше решение могут сломать, просто передав невалидные аргумент, если только мы не подумаем об этом заранее.   Далее, ищем существующие решения. Задачу с числами Фибоначчи решили уже множество раз, поэтому, наверняка можно нагуглить библиотеку или метод из core библиотеки твоего языка программирования, который сделает расчёты за тебя. Выбираем подходящий метод. Пишем код метода, держа в уме ответы на вопросы, данные на первом этапе. Например, если отрицательные методы могут быть переданы, то добавляем в тело метода проверку входящих параметров. Проверяем, что решение работает. Раз уж речь идёт о собеседовании на программиста, то лучшим способом проверить решение и показать свою профпригодность будет написание юнит-теста.  Итак, предположим, мы прошли все этапы алгоритма, и метод, и использующий, написанную за нас библиотеку, прекрасно работает. Интервьюер не удовлетворён и просит нас в этот раз не использовать чужие библиотеки.\nОтлично! В этом случае, мы понимаем, что ошибка произошла на втором шаге алгоритма - мы выбрали не подходящее решение. И теперь, ищем существующие алгоритмы для решения проблемы. Можно воспользоваться восходящим вычислением, можно нисходящим. Выбрав подход, переделываем код метода. Юнит тест для проверки работоспособности нашего метода уже есть. Так что, решение задачи в этот раз будет легче.\nЗачем программисту знать про Problem Solving Skill? Удалённая работа А вот этот вопрос, я задавал себе много раз, пока не начал работать удалённо. Дело в том, что удалённая работа подразумевает умение решать задачи самостоятельно. В remote режиме, нет старшего товарища, который поможет советом или следить за тем, что ты делаешь. Именно поэтому зачастую компании, которые предлагают remote позиции разработчиков не рассматривают разработчиков junior и даже middle уровней. Им требуются люди, способные проанализировать поставленную задачу и, либо, способные решить её, либо, способные предложить альтернативные подходы. Если быть точным - способные взять на себя полную ответственность за задачу.\nСобеседования Второй областью, в которой этот навык может быть крайне полезен для разработчика - это собеседования. Последние годы даже в вакансиях стало модным писать про наличие Problem Solving Skill. И его наличие рассматривается на собеседовании как раз таки с помощью различных задач, не имеющих чёткого решения. Это то, что зачастую интервьюером называется «нам интересно посмотреть на Ваш ход мыслей».\nВ следующий раз, услышав фразу про «ход мыслей» ты уже будешь готов продемонстрировать свой навык.\nВ качестве завершения Надеюсь, прочитав эту статью, ты найдёшь для себя много полезного.\nСо своей стороны, скажу что умение работать в плане решения чётко и последовательно - это прекрасный навык, который как поможет в решении поставленных задач, так и прекрасно дополнит твоё резюме.\n","date":"October 5, 2021","hero":"/images/default-hero.jpg","permalink":"/posts/soft-skills/content/problem-solving-skill/","summary":"Что такое Problem Solving? Это умение решать проблемы. Всё, расходимся. 😁\nПошутили?! Давай разбираться! Это действительно умение решать проблемы, но что такое «решать проблемы»? Как это «решать проблемы»? Да и что такое «проблема» вообще?\nЧто такое «Проблема»? Под «проблемой» в IT понимается любая задача или ситуация решение которой требуется найти. Для разработчика такой «проблемой» может стать очередная задача, выданная ему менеджером или же алгоритмическая задача, данная ему на собеседовании.\nПростые проблемы не рассматриваются в рамках Problem Solving Skill темы.","tags":["softskills","skills"],"title":"🇷🇺 Problem Solving Skill"},{"categories":null,"contents":"Изначально, это статью Я написал для своего блога на Medium [1]. Сюда переношу её почти без изменений. Что такое API? API или Application Programming Interface — это описание способа взаимодействия программ. Если быть точнее, это набор классов, интерфейсов, структур данных, которые объявлены программой. С помощью них можно заставить программу выполнять действия. Какие именно действия — описано как раз таки в API.\nAPI’ев существует огромное множество. Например, сама Java даёт разработчику доступ к десяткам API — Core API, Concurrency API, Collection API и много много других. Сторонние фреймворки тоже предоставляют свои API — Hibernate API, JPA (Java Persistence API), RestEasy и другие.\nУ каждого API есть своя цель. API’и не делают просто так. Каждый API сродни пульту управления от телевизора. Он даёт возможность управлять программой. Например, программа для анализа использования дискового пространства может содержать API, который позволит получить статистику о файлах и занятом ими пространнстве; укажет на самый тяжёлый файл на диске и так далее. При этом каждое API не позволяет делать произвольные вещи. Все возможности API согласованы с его целью.\nAPI’и не привязаны к конкретной технологии. Если программа написана на Java это не означает, что API ограничен этим языком программирования. Приложение может предоставлять API, не привязанное к конкретной технологии, на которой оно построено. Пример — REST API.\nЧто такое REST API? REST или Representational State Transfer («передача состояния представления») это архитектурный подход, основанный на протоколе HTTP.\nЗачем проектировать REST API? Построение программ — это игра в конструктор без жёстких правил. Победить в этой игре могут все. Но настоящее искусство программиста это написание таких программ, которые будут работать быстро, безотказно и легко расширяться. Поэтому, как и при стройке дома, важно знать заранее что и как будет построено, ибо цена ошибки на этапе проектирование ниже, чем цена ошибки в момент, когда дом уже готов.\nПредметно-ориентированное проектирование REST API Техника, которой я сегодня поделюсь хорошо описана в книге издательства Manning — “The Design of Web APIs\u0026quot; [2]. Ссылку на книгу можно найти в конце статьи.\nНебольшая вводная, прежде чем мы приступим к рассмотрению методики. Все идеи и советы ниже крайне ориентированы на практику. Это не теоретические знания, это живой метод проектирования REST API, поэтому и разбирать мы его будем на живом примере. Представьте, что Нам нужно спроектировать REST API для блог-сервиса. Конкретно, Мы отвечаем за работу с постами и их комментариями. На примере этого требования мы и разберёмся с методом.\nКакие цели могут быть у такого API? Пожалуй их будет несколько:\n Прочитать имеющиеся посты. Должен быть способ получить список уже имеющихся постов. Изменение имеющегося поста. Что если в текст прокралась ошибка? Автор должен иметь возможность её поправить после написания и публикации поста. Создание нового поста. Как-то же пост попадает наш блогосервис. Удаление поста. Автор решил удалить свой устаревший пост или пост с идеями, в которые он больше не верит. Чтение комментариев к посту. Для краткости предположим что комментарии попадают в наш блогосервис каким-то иным способом, не через наше REST API. Однако, в нашем REST API мы хотим разрешить пользователям читать комментарии для имеющихся постов.  Эти цели мы транслируем в REST API.\nТеперь разберёмся с основными правилами:\n Цели транслируются в ресурсы и действия Ресурсы определяются путём в REST API, а действия определяются методами HTTP  Что такое ресурс? Ресурс это объект, представление, сущность, всё что угодно, что представляет данные в системе. В нашем блогосервисе ресурсов несколько — Пост и Комментарий.\nЧто такое действие? Действие это способ заставить наш блогосервис что-то сделать, например — отдать список имеющихся постов, создать новый и так далее. Действия определяются методами HTTP протокола, как уже было сказано выше. Таких действий несколько, но нас интересуют стандартные: GET, POST, PUT, DELETE.\nПерейдём к самому проектированию. Разберём его по шагам:\n Перво-наперво нужно определить все ресурсы и под-ресурсы, с которыми наше API должно работать. В нашем случае это Пост и Комментарий. Далее, нужно определить набор действий, которые наше API позволяет совершать над ресурсами. Для нас это:   GET Пост — для получения списка имеющихся постов POST Пост — для создания нового поста PUT Пост — для изменения имеющегося поста DELETE Пост — для удаления поста GET Комментарий — для получения списка комментариев поста   Определим набор параметров для действий, которые мы спроектировали выше:   Операция получения постов GET — может быть вызвана как без параметров, что приведёт к чтению всех имеющихся постов, так и с идентификатором конкретного поста для получения выбранного поста Операция создания поста POST подразумевает, что в неё будет передана информация о посте, который необходимо создать PUT требует двух параметров — идентификатора поста, который мы будем изменять и сам пост, который заменит имеющийся в блогосервисе DELETE требует идентификатора поста, который необходимо удалить Операция получения комментариев GET требует идентификатора поста, потому что мы хотим получить список комментариев к определённому посту  Прервёмся на секунду. Мы провели большую подготовительную работу для сбора данных о нашем будущем API. Теперь мы знаем как конкретно и с чем конкретно наше API будет работать. Но эту информацию стоит дополнить и на следующем шаге мы займёмся именно этим.\nНа какие ещё моменты нам стоит обратить внимание? Их несколько. Нужно ответить на следующие вопросы:\n Кто будет вызывать операции API? Что и как будет делать этот кто-то с нашим API?  Небольшая ремарка — структура статьи на Medium не позволяет создать таблицу, хотя дальнейшую работу по проектированию нашего REST API я рекомендую проводить именно с таблицами. Поэтому дальше — мы в текстовом виде разберём что нам нужно делать, но я подразумеваю, что все моменты которые мы оговорим будут внесены в специальную таблицу.\nНаша таблица проектирования — наш помощник. Список её колонок следующий:\n Кто — тут могут быть роли пользователей, которые будут работать с нашим API Что — имеется ввиду что делает пользователь с нашим API. Его ожидания Как — опять же, как наш пользователь достигает своей цели Входные данные — информацию, которую необходимо передать нашему API, для того, чтобы оно помогло пользователю достигнуть цели Выходные данные — информация, которую вернёт наш API в результате работы метода Цель — описывает явно смысл конкретной операции нашего API HTTP метод — указание на HTTP метод, который описывает действие нашего пользователя URI — путь по которому данная операция нашего API доступна клиентам  Всё что нам осталось сделать, это на основе информации, которую мы проговорили выше заполнить эту табличку. Попробуем сделать это для операции получения постов:\nРазберём подробнее. Раз уж мы работаем с постами, то кто-то их должен писать. Это будет Автор. Автор может получить доступ ко всем своим постам, поэтому для операции чтения постов нам не требуется никаких входных данных. Реализация самого API может установить текущего пользователя системы и определить авторство постов. На выходе же мы получим список постов, которые были написаны автором (или текущем залогиненным пользователем). Операция получения данных описывается в HTTP протоколе методом GET, а URI в конце, может иметь произвольную структуру, но общепринято в хвосте URL путь писать с указанием ресурса с которым в данном API мы работаем во множественном числе. В нашем случае это …/posts.\nПо мере заполнения таблицы, всегда задаём себе вопросы — откуда берутся ресурсы, кто с ними работает и так далее. Чем шире посмотреть на имеющиеся данные, тем больше возможных кейсов можно идентифицировать на этапе проектирования. Простой пример — мы спроектировали операцию получения авторских постов. Но кто эти посты добавляет в систему? Очевидно, что авторы. Спроектируем и это:\nПользуясь этим подходом спроектируем оставшиеся операции:\nОбратите внимание на последнюю строку. Мы уже коснулись темы подресурсов выше. В таблице на картинке выше Вы можете заметить как выглядит URI для доступа к комментариям поста. В пути сначала пишется родительский ресурс, а потом уже указание на подресурс: /api/[resource]/{id}/[sub-resource]. Это общепринятая практика и подобное построение пути даёт возможность пользователям Вашего API сразу понять какие ресурсы зависят от других.\nВ заключение, хочется задать вопрос — Подходит ли спроектированное нами API на все случаи жизни? Конечно же — нет. Если Вы присмотритесь к таблице внимательнее, станет ясно, что это API предназначено исключительно для Авторов постов. Автор может читать только свои посты. А вот пользователи блогосервиса должны получать доступ ко всем постам всех авторов. Такие вот моменты становятся видны, если на этапе проектирования каждой из операции задавать вопросы о том, кто будет пользоваться ими и в каких случаях.\nНадеюсь эта статья поможет Вам подступиться к такой огромной теме как REST API’и и направит Вас в моменты, когда придётся проектировать собственное API.\nПолезные ссылки  [1] Мой старый блог на Medium [2] Книга \u0026ldquo;The Design of Web APIs\u0026rdquo; на Manning  ","date":"October 3, 2021","hero":"/images/default-hero.jpg","permalink":"/posts/design/content/design-rest-api/","summary":"Изначально, это статью Я написал для своего блога на Medium [1]. Сюда переношу её почти без изменений. Что такое API? API или Application Programming Interface — это описание способа взаимодействия программ. Если быть точнее, это набор классов, интерфейсов, структур данных, которые объявлены программой. С помощью них можно заставить программу выполнять действия. Какие именно действия — описано как раз таки в API.\nAPI’ев существует огромное множество. Например, сама Java даёт разработчику доступ к десяткам API — Core API, Concurrency API, Collection API и много много других.","tags":["design","restapi"],"title":"🇷🇺 Как проектировать REST API?"},{"categories":null,"contents":"Давай знакомиться Рад приветствовать тебя на своём скромном островке в огромном океане Интернета.\nВсю свою сознательную профессиональную жизнь Я являюсь разработчиком программного обеспечения и пишу абсолютно разные приложения на языке программирования Java:\n от мелких консольных утилит до тяжёлых энтерпрайз приложений от небольших и легко поддерживаемых микросервисов до гигантских монолитов  В своё время моей страстью была и мобильная разработка, где Я успел написать несколько приложений как на заказ, так и для себя, под iOS \u0026amp; Android, на Swift и Java, соответсвенно.\nЗанимаюсь Я этим довольно давно и поэтому в последние пару лет назрело острое желание вернуть долг индустрии, которая научила меня многому, и помочь будущим поколениям сделать \u0026ldquo;быстрый старт\u0026rdquo; в их карьере.\nНа моём сайте ты сможешь найти материалы на такие темы как:\n архитектура и проектирование программного обеспечения навыки современного разработчика, нацеленного на рост тонкости использования различных технологий  и многие другие, которые помогут тебе взглянуть шире на карьеру разработчика.\nКонтакты Меня можно найти тут:\n Вконтакте Github  Другие проекты   YouTube-канал #НЕмузыкант\n  YouTube-канал noПрограммист\n  Моя музыка на Spotify\n  Моя музыка на Apple Music\n  ","date":"October 3, 2021","hero":"/images/default-hero.jpg","permalink":"/about/","summary":"Давай знакомиться Рад приветствовать тебя на своём скромном островке в огромном океане Интернета.\nВсю свою сознательную профессиональную жизнь Я являюсь разработчиком программного обеспечения и пишу абсолютно разные приложения на языке программирования Java:\n от мелких консольных утилит до тяжёлых энтерпрайз приложений от небольших и легко поддерживаемых микросервисов до гигантских монолитов  В своё время моей страстью была и мобильная разработка, где Я успел написать несколько приложений как на заказ, так и для себя, под iOS \u0026amp; Android, на Swift и Java, соответсвенно.","tags":["me"],"title":"Обо мне"},{"categories":null,"contents":"Цикл статей о Domain Driven Design  1️⃣ DDD 101: Заметки о Domain Driven Design #1  🗺 Моделирование  ⚠️ Идентификация рисков - Risk Storming 🗾 Карты Пользовательских Историй или User Story Mapping 📶 Уровни детализации Use Case\u0026rsquo;ов  🏗 Проектирование  🧩 Проектирование REST API  🧸 Софт-скиллы  😎 Навык решения проблем или Problem Solving Skill ⭐️ Техника построения речи S.T.A.R.  Hibernate framework  Hibernate N+1 Проблема  ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"/showcase/","summary":"Цикл статей о Domain Driven Design  1️⃣ DDD 101: Заметки о Domain Driven Design #1  🗺 Моделирование  ⚠️ Идентификация рисков - Risk Storming 🗾 Карты Пользовательских Историй или User Story Mapping 📶 Уровни детализации Use Case\u0026rsquo;ов  🏗 Проектирование  🧩 Проектирование REST API  🧸 Софт-скиллы  😎 Навык решения проблем или Problem Solving Skill ⭐️ Техника построения речи S.T.A.R.  Hibernate framework  Hibernate N+1 Проблема  ","tags":null,"title":""},{"categories":null,"contents":"Писать заметки в блокноте - это хобби.\nПисать статьи с целью \u0026ldquo;научить\u0026rdquo; - это работа.\nЯ делаю это, потому что хочу быть благодарен IT-сообществу за то, кем я стал. Я делаю это, потому что во времена когда учился я, у меня не было человека, который бы \u0026ldquo;разжевал\u0026rdquo; сложные для меня темы\u0026hellip; Я делаю это в своё свободное время, предпочитая создание полезных материалов вместо развлечений, или проведения бОльшего количества времени со своей семьёй.\nЕсли мои статьи были для тебя полезны, ты можешь отблагодарить меня кликнув на картинку ниже. Твоя поддержка мотивирует меня писать больше.\n⬇⬇⬇\t⬇⬇⬇\t⬇⬇⬇\t⬇⬇⬇\t⬇⬇⬇\n\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"/support/","summary":"Писать заметки в блокноте - это хобби.\nПисать статьи с целью \u0026ldquo;научить\u0026rdquo; - это работа.\nЯ делаю это, потому что хочу быть благодарен IT-сообществу за то, кем я стал. Я делаю это, потому что во времена когда учился я, у меня не было человека, который бы \u0026ldquo;разжевал\u0026rdquo; сложные для меня темы\u0026hellip; Я делаю это в своё свободное время, предпочитая создание полезных материалов вместо развлечений, или проведения бОльшего количества времени со своей семьёй.","tags":null,"title":""},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"/search/","summary":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```","tags":null,"title":"Search Results"}]