<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>restapi on Anver Bogatov</title><link>/tags/restapi/</link><description>Recent content in restapi on Anver Bogatov</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 20 Nov 2021 18:55:34 +0400</lastBuildDate><atom:link href="/tags/restapi/index.xml" rel="self" type="application/rss+xml"/><item><title>How to design a REST API?</title><link>/posts/design-rest-api/</link><pubDate>Sat, 20 Nov 2021 18:55:34 +0400</pubDate><guid>/posts/design-rest-api/</guid><description>What is API? API or Application Programming Interface — is a description of communication between two programs.
To be even more precise, an API is a set of classes, interfaces, or data structures that are defined by the program that owns the API.
With the API, you can make a program do something. What exactly - defined by the API.
There are many APIs exist.
For example, Java itself gives access to dozens of APIs to developers: Core API, Concurrency API, Collection API and many more.</description><content>&lt;h1 id="what-is-api">What is API?&lt;/h1>
&lt;p>&lt;strong>API or Application Programming Interface&lt;/strong> — is a description of communication between two programs.&lt;/p>
&lt;p>To be even more precise, an API is a set of classes, interfaces, or data structures that are defined by the program that owns the API.&lt;/p>
&lt;p>With the API, you can make a program do something. What exactly - defined by the API.&lt;/p>
&lt;p>&lt;strong>There are many APIs exist&lt;/strong>.&lt;/p>
&lt;p>For example, Java itself gives access to dozens of APIs to developers: Core API, Concurrency API, Collection API and many more.&lt;/p>
&lt;p>Other frameworks define their own APIs: Hibernate API, JPA (Java Persistence API), RestEasy, and so on.&lt;/p>
&lt;p>&lt;strong>Each of the APIs has its own goal&lt;/strong>.&lt;/p>
&lt;p>APIs are not created just for fun. Each of the APIs is like a TV remote control. It gives an opportunity to control the application.&lt;/p>
&lt;p>For example, an application for disk space usage analysis can contain an API that allows getting statistics on files and the space they take; this will point to the heaviest file on the disk drive and so on.&lt;/p>
&lt;p>At the same time, the API does not allow doing any random stuff. All the capabilities of the API are consistent with its goal.&lt;/p>
&lt;p>&lt;strong>APIs do not belong to concrete technology&lt;/strong>.&lt;/p>
&lt;p>If an application is written in Java, that does not mean that the API will be limited to that particular programming language. Applications can communicate through APIs written using different technologies and programming languages.&lt;/p>
&lt;p>For example, REST API.&lt;/p>
&lt;h1 id="what-is-rest-api">What is REST API?&lt;/h1>
&lt;p>REST or Representational State Transfer is an architectural approach based on the HTTP protocol.&lt;/p>
&lt;h1 id="why-do-you-need-to-design-a-rest-api">Why do you need to design a REST API?&lt;/h1>
&lt;p>&lt;strong>Application development is like collecting a puzzle without hard rules&lt;/strong>.&lt;/p>
&lt;p>Everybody can win that game. But the true mastery of software engineering is writing software applications that will work quickly, without errors, and will be extensible.&lt;/p>
&lt;p>That is why, as in house building, you need to know everything beforehand, because the cost of a mistake on&lt;/p>
&lt;p>design stage cheaper than the cost of a mistake at the moment when the house is built.&lt;/p>
&lt;h1 id="domain-driven-design-of-rest-api">Domain driven design of REST API&lt;/h1>
&lt;p>&lt;strong>Technique that I am going to share today&lt;/strong> is well described in Manning&amp;rsquo;s book - &amp;ldquo;The Design of Web APIs&amp;rdquo; [1].&lt;/p>
&lt;p>The link to the book can be found at the bottom of the page.&lt;/p>
&lt;p>&lt;strong>Small input&lt;/strong>, before I will explain the method. All the ideas below are highly oriented onto practice.&lt;/p>
&lt;p>The method is not just a dry theory, but rather a live method of REST API design. Thus, we will talk about it using live&lt;/p>
&lt;p>example. Imagine that we need to design a REST API for some blog service. To be precise, we will work with&lt;/p>
&lt;p>posts and their comments. Using that requirement as an example, we will use the method.&lt;/p>
&lt;p>&lt;strong>What goals such API can have?&lt;/strong> There can be even multiple goals:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Read posts. There should be a way to read existing posts.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Modify posts. What if there is a mistake in a particular post? It&amp;rsquo;s author must have a way to fix the mistake after post was published.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create post. Posts must be added to our service somehow.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Delete post. When author decided to remove own post.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Read post&amp;rsquo;s comments. For brevity&amp;rsquo;s sake, let&amp;rsquo;s agree that comments are added to our service some other way.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>These goals we will translate to our REST API.&lt;/p>
&lt;p>&lt;strong>Now, let&amp;rsquo;s define main rules&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Goals are translated to &lt;strong>resources&lt;/strong> and &lt;strong>actions&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Resources&lt;/strong> are expressed as paths in REST API, and &lt;strong>actions&lt;/strong> are expressed as HTTP protocol&amp;rsquo;s methods.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>What is a resource?&lt;/strong> Resource is an object, a view, or an entity - literally it can be anything that means some data&lt;/p>
&lt;p>in the service. There are two resources in our blog service - Post and Comment.&lt;/p>
&lt;p>&lt;strong>What is action?&lt;/strong> Action is a way to ask our blog service to do something, for example, to get existing posts or&lt;/p>
&lt;p>to create a new one. Actions are expressed as methods of HTTP protocol, as was said above. The HTTP protocol defines&lt;/p>
&lt;p>multiple such methods, but we are interested in standard ones: GET, POST, PUT, DELETE.&lt;/p>
&lt;p>&lt;strong>Now, let&amp;rsquo;s go to the method&lt;/strong>. Let&amp;rsquo;s break it down into steps:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>First of all, we need to define all the resources and sub-resources with which our API must work. In our case, these are &lt;strong>Post&lt;/strong> and &lt;strong>Comment&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Next, we need to define a list of actions that our API must allow us to do. For us, the list is the following:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>GET Post — for access to existing posts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST Post — for new post creation&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PUT Post — for existing post modification&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELETE Post — for existing post deletion&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GET Comment — for access to the existing post&amp;rsquo;s comments&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Let&amp;rsquo;s define a list of parameters for the actions from above:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>GET posts action can be called without parameters, and that will lead to access to all of the existing posts. It can also be called with the identifier of a concrete post and will return only the post with the identifier specified as a parameter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>POST action implies that there should be new post data used for new post creation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PUT action requires two parameters —the identifier of the post that we will modify and the post&amp;rsquo;s data that will replace existing data.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELETE action requires to have post&amp;rsquo;s id to know which of the posts must be deleted&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GET post&amp;rsquo;s comments action requires identifier of the post for which comments must be returned&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Let&amp;rsquo;s stop for a second&lt;/strong>.&lt;/p>
&lt;p>We did a huge preparation to get as much information as we can about our future API. And now we know how our API should work.&lt;/p>
&lt;p>But that information is not enough, and we need to collect additional information. That we will do right now.&lt;/p>
&lt;p>What else do we need to know? Basically, we need to answer onto following questions:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Who will use our API?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>What and how exactly that &amp;lsquo;who&amp;rsquo; will do with our API?&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>There is a special structure we can use specifically to collect all information we need. It can be represented as a table&lt;/p>
&lt;p>with predefined list of columns:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Who&lt;/strong> — means users, persons, roles, clients and so on; it means who will use our API&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>What&lt;/strong> — means expectations of the user about our API (&amp;ldquo;what to expect?&amp;quot;)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>How&lt;/strong> — means how we will reach his goal&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Input&lt;/strong> — data that must be given to our API so that it can help our user reach his goal&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Output&lt;/strong> — data that will be returned to the user as the result&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Goal&lt;/strong> — describes goal of particular operation&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>HTTP method&lt;/strong> — points onto HTTP method that describes an action that our user does&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>URI&lt;/strong> — path to particular API operation&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/images/design-rest-api/1.en.png" alt="design-rest-api-table-1">&lt;/p>
&lt;p>&lt;strong>All is left to do is fill in the table&lt;/strong> with data based on the information we gathered. Let&amp;rsquo;s try to do that for GET posts operation:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/2.en.png" alt="design-rest-api-table-2">&lt;/p>
&lt;p>&lt;strong>Let&amp;rsquo;s look closer on it&lt;/strong>. We work with posts. That means that somebody needs to write them. So, every post has its own Author.&lt;/p>
&lt;p>The author can get access to all of his posts. For that, we do not need to provide any specific input and under the hood implementation of the API&lt;/p>
&lt;p>can detect current user and detect his posts. As the output we will have a list of posts written by current user (Author).&lt;/p>
&lt;p>Read operation in HTTP protocol expressed as GET method. And finally according to commonly used approach URI must end with&lt;/p>
&lt;p>name of the resource. In our case it will be &lt;code>.../posts&lt;/code>.&lt;/p>
&lt;p>&lt;strong>During filling in the table, always aks yourself following questions&lt;/strong> - where are resources from? who works with them? and so on.&lt;/p>
&lt;p>The bigger picture you will try to see, the more cases you can identify on the design stage. Simple example:&lt;/p>
&lt;p>We have designed operation of getting the posts, but who had added them before? Author, of course. Let&amp;rsquo;s design that as well:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/3.en.png" alt="design-rest-api-table-3">&lt;/p>
&lt;p>Using same approach &lt;strong>let&amp;rsquo;s design rest of operations&lt;/strong>:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/4.en.png" alt="design-rest-api-table-4">&lt;/p>
&lt;p>&lt;strong>Pay attention onto last row&lt;/strong>. We have discussed sub-resources before. On the screenshot from above you can notice how URI&lt;/p>
&lt;p>for sub-resources access can look like. In our example, how URI for accessing post&amp;rsquo;s comments can look like. At the beginning of the path&lt;/p>
&lt;p>name of the parent resource must be given and only after that name of sub-resource can be used. According to that&lt;/p>
&lt;p>the schema for URI can look like this: &lt;code>/api/[resource]/{id}/[sub-resource]&lt;/code>. This is a commonly used practice and URIs like this allow&lt;/p>
&lt;p>your users to understand which of resources depends on others.&lt;/p>
&lt;p>&lt;strong>As an outro, we need to ask ourselves one question - Will the API we have designed fit all the cases in any situations? Of course - not&lt;/strong>.&lt;/p>
&lt;p>If you look onto the table closer, it becomes clear for you that the API we have designed is intended to be used only by Authors.&lt;/p>
&lt;p>Author can read only own posts, but users of blog service must have access to all posts of all authors. Such requirements (you can also call them as constraints)&lt;/p>
&lt;p>become visible during design stage, only if you try to get the big picture by asking yourself questions about your resources, actions, users, cases and so on.&lt;/p>
&lt;p>&lt;strong>I hope that this article will help you&lt;/strong> to understand that REST APIs can be designed using simple and formalised algorithm.&lt;/p>
&lt;h1 id="useful-links">Useful links&lt;/h1>
&lt;ul>
&lt;li>[1] &amp;ldquo;The Design of Web APIs&amp;rdquo; book &lt;a href="https://www.manning.com/books/the-design-of-web-apis">on Manning&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>