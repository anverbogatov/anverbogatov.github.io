<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>design on Anver Bogatov</title><link>/tags/design/</link><description>Recent content in design on Anver Bogatov</description><generator>Hugo -- gohugo.io</generator><language>ru-RU</language><lastBuildDate>Tue, 19 Oct 2021 10:36:26 +0400</lastBuildDate><atom:link href="/tags/design/index.xml" rel="self" type="application/rss+xml"/><item><title>Уровни детализации Use Case'ов</title><link>/posts/use-case-goal-levels/</link><pubDate>Tue, 19 Oct 2021 10:36:26 +0400</pubDate><guid>/posts/use-case-goal-levels/</guid><description>Введение Для того, чтобы разобраться с темой, нам понадобятся два понятия:
СЦЕНАРИЙ - это последовательность шагов, совершаемых в определённых условиях, с целью достижения определённой цели, и, оканчивающаяся результатом, который напрямую связан с целью. Эта последовательность начинается с действия, которое является триггером (причиной для начала), и продолжается до тех пор, пока не будет достигнута или провалена конечная цель.
ПРЕЦЕДЕНТ - это набор сценариев взаимодействия между системой и актёрами; отображает как именно цель основного актёра может быть достигнута или провалена.</description><content>&lt;h3 id="введение">Введение&lt;/h3>
&lt;p>Для того, чтобы разобраться с темой, нам понадобятся два понятия:&lt;/p>
&lt;p>&lt;strong>СЦЕНАРИЙ&lt;/strong> - это &lt;strong>последовательность шагов&lt;/strong>, совершаемых в определённых условиях, с целью достижения определённой цели, и, оканчивающаяся результатом, который напрямую связан с целью. Эта последовательность начинается с действия, которое является триггером (причиной для начала), и продолжается до тех пор, пока не будет достигнута или провалена конечная цель.&lt;/p>
&lt;p>&lt;strong>ПРЕЦЕДЕНТ&lt;/strong> - это &lt;strong>набор сценариев&lt;/strong> взаимодействия между системой и актёрами; отображает как именно цель основного актёра может быть достигнута или провалена. Например, прецедент оформления возмещения страховой выплаты в результате происшествия, будет включать в себя оба сценария - «успешная выплата» и «выплата невозможна из-за нарушения правил».&lt;/p>
&lt;p>Если быть совсем точным, то в состав одного ПРЕЦЕДЕНТА, могут войти один и более СЦЕНАРИЕВ.&lt;/p>
&lt;p>СЦЕНАРИИ, в свою очередь, могут быть двух видов:&lt;/p>
&lt;ul>
&lt;li>Основными и&lt;/li>
&lt;li>Альтернативными&lt;/li>
&lt;/ul>
&lt;p>Основной СЦЕНАРИЙ - это сценарий, описывающий успешное достижение конечной цели главным актёром.&lt;/p>
&lt;p>Альтернативный СЦЕНАРИЙ - это сценарий, описывающий безуспешное достижение конечной цели главынм актёром, или же последовательность шагов, позволяющую достичь своей цели, после её провала.&lt;/p>
&lt;p>&lt;img src="/images/use-case-goal-levels/1.png" alt="use-case-mind-map">&lt;/p>
&lt;h4 id="примеры">Примеры&lt;/h4>
&lt;p>Скорее всего, описание Вам покажется неясным. Особенно, описание Альтернативного СЦЕНАРИЯ, однако, всё встанет на свои места, как только мы разберёмся с примером.&lt;/p>
&lt;p>Представьте, что мы составляем ПРЕЦЕДЕНТ, в котором Клиент (основной актёр) резервирует столики в системе обслуживания ресторана. Примером &lt;strong>основного СЦЕНАРИЯ&lt;/strong>, в таком случае может быть следующий сценарий:&lt;/p>
&lt;ol>
&lt;li>Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время&lt;/li>
&lt;li>Администратор проверяет наличие столика и подтверждает резерв&lt;/li>
&lt;/ol>
&lt;p>В этом случае, цель пользователя достигнута полностью - клиент получил столик в распоряжение в оговорённое время.&lt;/p>
&lt;p>&lt;strong>Альтернативный СЦЕНАРИЙ&lt;/strong>, в котором &lt;strong>цель&lt;/strong> основного актёра будет &lt;strong>провалена&lt;/strong>, может выглядеть следующим образом:&lt;/p>
&lt;ol>
&lt;li>Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время&lt;/li>
&lt;li>Администратор проверяет наличие столика и сообщает Клиенту о том, что в наличии свободного столика на оговорённую дату не имеется&lt;/li>
&lt;/ol>
&lt;p>Ну и наконец, &lt;strong>альтернативный СЦЕНАРИЙ&lt;/strong>, в котором &lt;strong>цель&lt;/strong> основного актёра будет &lt;strong>достигнута после&lt;/strong> её первоначального &lt;strong>провала&lt;/strong> будет выглядеть так:&lt;/p>
&lt;ol>
&lt;li>Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время&lt;/li>
&lt;li>Администратор проверяет наличие столика и сообщает Клиенту о том, что в наличии свободного столика на оговорённую дату не имеется&lt;/li>
&lt;li>Администратор проверяет наличие столика на время ближайшее к оговорённому ранее и предлагает эту дату и время Клиенту&lt;/li>
&lt;li>Клиент подтверждает своё согласие на новую дату и время&lt;/li>
&lt;li>Администратор подтверждает резерв&lt;/li>
&lt;/ol>
&lt;h3 id="уровни-детализации">Уровни детализации&lt;/h3>
&lt;p>В своей работе под названием &amp;ldquo;Structuring Use cases with goals&amp;rdquo;, Алистер Кокбёрн, вводит понятие уровня моря, как &amp;ldquo;золотое сечение&amp;rdquo; степени детализации ПРЕЦЕДЕНТА и СЦЕНАРИЯ. Переводится это буквально - sea level (на следующем изображении, он подписан как &amp;ldquo;User Goal Level&amp;rdquo;).&lt;/p>
&lt;p>&lt;img src="/images/use-case-goal-levels/2.png" alt="use-case-granularity">&lt;/p>
&lt;p>Если внимательно посмотреть на изображение выше, можно увидеть, три больших уровня. На двух из них, существуют подуровни. Перечислим их:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Summary Level&lt;/strong> - можно перевести как &amp;ldquo;Уровень обобщения&amp;rdquo;. Он имеет два подуровня:
&lt;ul>
&lt;li>Cloud Level - буквально - &amp;ldquo;Уровень небес&amp;rdquo;&lt;/li>
&lt;li>Kite Level - &amp;ldquo;Уровень кайта&amp;rdquo;. Аналогии с предметами из жизни в данной модели приведены неспроста. Запущенный в небо кайт, летает ниже уровня облаков.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Sea Level&lt;/strong> (User Goal Level) - &amp;ldquo;Уровень моря&amp;rdquo;.&lt;/li>
&lt;li>&lt;strong>Subfunctions Level&lt;/strong>
&lt;ul>
&lt;li>Fish / Indigo Level&lt;/li>
&lt;li>Clam / Black Level&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Давайте поговорим о каждом из них.&lt;/p>
&lt;h4 id="summary-level">Summary Level&lt;/h4>
&lt;p>Summary Level или Уровень обобщения - это уровень на котором процессы видны в контексте их жизненного цикла. Что это значит, это значит что уровень деталей настолько мал, что мы можем изображать процесс, который в жизни занимает многие дни и даже годы. Каждый шаг на данном уровне имеют свою уникальную конечную цель и может быть представлен в деталях на Уровне моря.&lt;/p>
&lt;p>Кокбёрн выделяет два подуровня на Уровне обобщения:&lt;/p>
&lt;h5 id="cloud-level">Cloud Level&lt;/h5>
&lt;p>Уровень небес отображает процессы с наименьшим количеством деталей. ПРЕЦЕДЕНТОВ, описываемых на данном уровне может быть крайне мало, буквально, 5-6 на всю организацию. Примерами могут быть: реклама товаров, продажа товаров потребителям, управление ресурсами и т.д.&lt;/p>
&lt;h5 id="kite-level">Kite Level&lt;/h5>
&lt;p>Уровень кайта показывает обобщённые ПРЕЦЕДЕНТЫ. Сами же ПРЕЦЕДЕНТЫ на этом уровне изображаются на уровне департаментов, но продолжают отображать обобщённые цели. Примерами могут быть: регистрация пассажира на рейс, оформление билета на рейс.&lt;/p>
&lt;h4 id="sea-level-user-goal-level">Sea Level (User Goal Level)&lt;/h4>
&lt;p>На Уровне моря бизнес-процессы описываются уже более детализированно, чем на уровнях выше. Сам Кокбёрн рекомендует задавать следующие вопросы при разработке ПРЕЦЕДЕНТОВ и их СЦЕНАРИЕВ с этим уровнем детализации - &amp;ldquo;Может ли основной актёр уйти удовлетворённым после выполнения этого процесса? Достиг ли основной актёр своей конечной цели?&amp;rdquo;. Примерами могут быть: добавление товара в корзину, оформление заказа и т.д.&lt;/p>
&lt;p>Всё, что проектируется с уровнем детализации ниже Уровня моря скорее относится к системному дизайну, нежели к бизнес проектированию.&lt;/p>
&lt;h4 id="subfunctions-level">Subfunctions Level&lt;/h4>
&lt;p>Ниже Уровня моря лежат мелкие детали. Зачастую, люди из бизнеса не слишком заинтересованы в подобной детализации процессов, однако, людям из разработки подобный уровень детализации позволяет получить больше информации о технических аспектах реализации процесса.&lt;/p>
&lt;p>Кокбёрн выделяет следующие два под уровня:&lt;/p>
&lt;h5 id="fish--indigo-level">Fish / Indigo Level&lt;/h5>
&lt;p>Примерами могут быть: поиск кода аэропорта определённого города, отображение списка клиентов, после ввода имени и т.д.&lt;/p>
&lt;h5 id="clam--black-level">Clam / Black Level&lt;/h5>
&lt;p>Это самый низкий уровень с наибольшим количеством деталей. Подобная детализация может оказаться излишней даже для людей из разработки. Примерами могут быть: валидация введённых в поле данных, добавление нового поля в форму и т.д.&lt;/p>
&lt;h3 id="пример-с-картой">Пример с картой&lt;/h3>
&lt;p>Нужны ли все эти уровне в описании бизнес-процессов? Думаю, что нет. Однако, здорово иметь подобную свободу, ведь, каждый может выбрать способ описания ПРЕЦЕДЕНТОВ и СЦЕНАРИЕВ, подходящий конкретно ему.&lt;/p>
&lt;p>В любом случае, если после описания выше Вам всё ещё затруднительно разобраться, что это всё означает, я приведу пример с картой, который напрямую отображает некоторые уровни детализации.&lt;/p>
&lt;p>Итак, предположим, что у нас есть ПРЕЦЕДЕНТ - &amp;ldquo;Добраться из Самары в Москву&amp;rdquo;. Процесс перемещения из одного города в другой можно описать разными предложениями, с указанием разных деталей. Визуально, маршрут легко представить с помощью карты:&lt;/p>
&lt;p>&lt;img src="/images/use-case-goal-levels/3.jpg" alt="use-case-granularity-in-map">&lt;/p>
&lt;p>Как не сложно догадаться, все три картинки, отображают части маршрута от Самары до Москвы с разным удалением от уровня земли. Чем ближе к поверхности земли, тем больше деталей нам доступно.&lt;/p>
&lt;p>&lt;strong>Карта #1&lt;/strong> показывает весь маршрут с высоты Уровня небес. Глядя на маршрут с такой высоты мы можем описать его только фразами вида: &amp;ldquo;Выезжаем из Самарской области в сторону Пензы. Проезжаем Пензу и направляемся в сторону Рязани&amp;rdquo;. В жизни, перемещения на такие расстояния займут много часов.&lt;/p>
&lt;p>&lt;strong>Карта #2&lt;/strong> показывает участок маршрута на Уровне моря. Карта на этом уровне детализации содержит большее количество деталей. Маршрут на таком уровне детализации может быть описан примерно такими СЦЕНАРИЯМИ: &amp;ldquo;Выезжаем через северный выезд из города Самара и едем через посёлок Пребрежный в сторону Жигулёвска&amp;rdquo;. То есть, уровень детализации такой, что мы описываем перемещение между городами и сёлами в пределах одной области. Напомню, в случае с Уровнем небес, мы описывали перемещения между областями и большими городами.&lt;/p>
&lt;p>&lt;strong>Карта #3&lt;/strong> уже находится на Уровне Рыб (fish level), а значит содержит множество мелких деталей о маршруте. Если взглянуть на карту, можно увидеть маршрут с высокой детализацией - можно рассмотреть по каким именно улицам и дорогам нужно двигаться, где именно поворачивать, и т.д.&lt;/p>
&lt;h3 id="сферы-применения">Сферы применения&lt;/h3>
&lt;p>Напоследок, хочется порассуждать, а где же эти знания могут пригодиться?&lt;/p>
&lt;p>Действительно, разработчики в своей ежедневной практике практически не сталкиваются с разработкой ПРЕЦЕДЕНТОВ и бизнес требований, однако, всё же, это не значит, что навыки описания ПРЕЦЕДЕНТОВ с нужным уровнем детализации будут бесполезны.&lt;/p>
&lt;p>На мой взгляд, есть две сферы применения этих навыков в жизни разработчика:&lt;/p>
&lt;ol>
&lt;li>Это разработка и управление командой. В случае с разработкой, эти навыки позволяют правильно воспринимать требования их ПРЕЦЕДЕНТОВ, переданных в разработку. Сопоставляя конечную цель основного актёра и СЦЕНАРИИ, входящие в состав ПРЕЦЕДЕНТОВ, разработчик может как лучше понять детали будущей реализации системы, так и увидеть белые пятна в предложенных СЦЕНАРИЯХ (недостаток деталей).&lt;/li>
&lt;li>Это проектирование. Такие подходы к проектированию, как Domain Storytelling сильно завязаны на понятия СЦЕНАРИЯ и уровней детализации. Наличие навыка составления граммотных ПРЕЦЕДЕНТОВ и СЦЕНАРИЕВ играет ключевую роль в проектировании domain stories в подходе.&lt;/li>
&lt;/ol>
&lt;h3 id="словарь-терминов">Словарь терминов&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>СЦЕНАРИЙ&lt;/strong> - он же scenario, он же user story.&lt;/li>
&lt;li>&lt;strong>ПРЕЦЕДЕНТ&lt;/strong> - он же use case или сценарий использования.&lt;/li>
&lt;/ul>
&lt;h3 id="дополнительные-материалы">Дополнительные материалы&lt;/h3>
&lt;ul>
&lt;li>[1] Книга Алистера Кокбёрна &amp;ldquo;Writing Effective Use Cases&amp;rdquo; &lt;a href="https://www.ozon.ru/product/writing-effective-use-cases-1829617/?sh=jD1ziFN8">https://www.ozon.ru/product/writing-effective-use-cases-1829617/?sh=jD1ziFN8&lt;/a>&lt;/li>
&lt;li>[2] Методичка Алистера Кокбёрна &amp;ldquo;Structuring Use cases with goals&amp;rdquo; &lt;a href="https://www.researchgate.net/publication/2807676_Structuring_Use_cases_with_goals">https://www.researchgate.net/publication/2807676_Structuring_Use_cases_with_goals&lt;/a>&lt;/li>
&lt;li>[3] Статья &amp;ldquo;Use Case Modelling&amp;rdquo; &lt;a href="https://www.w3computing.com/systemsanalysis/use-case-modeling/">https://www.w3computing.com/systemsanalysis/use-case-modeling/&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Как проектировать REST API?</title><link>/posts/design-rest-api/</link><pubDate>Sun, 03 Oct 2021 18:55:34 +0400</pubDate><guid>/posts/design-rest-api/</guid><description>Изначально, это статью Я написал для своего блога на Medium [1]. Сюда переношу её почти без изменений. Что такое API? API или Application Programming Interface — это описание способа взаимодействия программ. Если быть точнее, это набор классов, интерфейсов, структур данных, которые объявлены программой. С помощью них можно заставить программу выполнять действия. Какие именно действия — описано как раз таки в API.
API’ев существует огромное множество. Например, сама Java даёт разработчику доступ к десяткам API — Core API, Concurrency API, Collection API и много много других.</description><content>&lt;pre>&lt;code>Изначально, это статью Я написал для своего блога на Medium [1].
Сюда переношу её почти без изменений.
&lt;/code>&lt;/pre>&lt;h1 id="что-такое-api">Что такое API?&lt;/h1>
&lt;p>&lt;strong>API или Application Programming Interface&lt;/strong> — это описание способа взаимодействия программ. Если быть точнее, это набор классов, интерфейсов, структур данных, которые объявлены программой. С помощью них можно заставить программу выполнять действия. Какие именно действия — описано как раз таки в API.&lt;/p>
&lt;p>&lt;strong>API’ев существует огромное множество&lt;/strong>. Например, сама Java даёт разработчику доступ к десяткам API — Core API, Concurrency API, Collection API и много много других. Сторонние фреймворки тоже предоставляют свои API — Hibernate API, JPA (Java Persistence API), RestEasy и другие.&lt;/p>
&lt;p>&lt;strong>У каждого API есть своя цель&lt;/strong>. API’и не делают просто так. Каждый API сродни пульту управления от телевизора. Он даёт возможность управлять программой. Например, программа для анализа использования дискового пространства может содержать API, который позволит получить статистику о файлах и занятом ими пространнстве; укажет на самый тяжёлый файл на диске и так далее. При этом каждое API не позволяет делать произвольные вещи. Все возможности API согласованы с его целью.&lt;/p>
&lt;p>&lt;strong>API’и не привязаны к конкретной технологии&lt;/strong>. Если программа написана на Java это не означает, что API ограничен этим языком программирования. Приложение может предоставлять API, не привязанное к конкретной технологии, на которой оно построено. Пример — REST API.&lt;/p>
&lt;h1 id="что-такое-rest-api">Что такое REST API?&lt;/h1>
&lt;p>REST или Representational State Transfer («передача состояния представления») это архитектурный подход, основанный на протоколе HTTP.&lt;/p>
&lt;h1 id="зачем-проектировать-rest-api">Зачем проектировать REST API?&lt;/h1>
&lt;p>&lt;strong>Построение программ — это игра в конструктор без жёстких правил&lt;/strong>. Победить в этой игре могут все. Но настоящее искусство программиста это написание таких программ, которые будут работать быстро, безотказно и легко расширяться. Поэтому, как и при стройке дома, важно знать заранее что и как будет построено, ибо цена ошибки на этапе проектирование ниже, чем цена ошибки в момент, когда дом уже готов.&lt;/p>
&lt;h1 id="предметно-ориентированное-проектирование-rest-api">Предметно-ориентированное проектирование REST API&lt;/h1>
&lt;p>&lt;strong>Техника, которой я сегодня поделюсь&lt;/strong> хорошо описана в книге издательства Manning — “The Design of Web APIs&amp;quot; [2]. Ссылку на книгу можно найти в конце статьи.&lt;/p>
&lt;p>&lt;strong>Небольшая вводная&lt;/strong>, прежде чем мы приступим к рассмотрению методики. Все идеи и советы ниже крайне ориентированы на практику. Это не теоретические знания, это живой метод проектирования REST API, поэтому и разбирать мы его будем на живом примере. Представьте, что Нам нужно спроектировать REST API для блог-сервиса. Конкретно, Мы отвечаем за работу с постами и их комментариями. На примере этого требования мы и разберёмся с методом.&lt;/p>
&lt;p>&lt;strong>Какие цели могут быть у такого API?&lt;/strong> Пожалуй их будет несколько:&lt;/p>
&lt;ul>
&lt;li>Прочитать имеющиеся посты. Должен быть способ получить список уже имеющихся постов.&lt;/li>
&lt;li>Изменение имеющегося поста. Что если в текст прокралась ошибка? Автор должен иметь возможность её поправить после написания и публикации поста.&lt;/li>
&lt;li>Создание нового поста. Как-то же пост попадает наш блогосервис.&lt;/li>
&lt;li>Удаление поста. Автор решил удалить свой устаревший пост или пост с идеями, в которые он больше не верит.&lt;/li>
&lt;li>Чтение комментариев к посту. Для краткости предположим что комментарии попадают в наш блогосервис каким-то иным способом, не через наше REST API. Однако, в нашем REST API мы хотим разрешить пользователям читать комментарии для имеющихся постов.&lt;/li>
&lt;/ul>
&lt;p>Эти цели мы транслируем в REST API.&lt;/p>
&lt;p>&lt;strong>Теперь разберёмся с основными правилами&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Цели транслируются в &lt;strong>ресурсы&lt;/strong> и &lt;strong>действия&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Ресурсы&lt;/strong> определяются путём в REST API, а &lt;strong>действия&lt;/strong> определяются методами HTTP&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Что такое ресурс?&lt;/strong> Ресурс это объект, представление, сущность, всё что угодно, что представляет данные в системе. В нашем блогосервисе ресурсов несколько — Пост и Комментарий.&lt;/p>
&lt;p>&lt;strong>Что такое действие?&lt;/strong> Действие это способ заставить наш блогосервис что-то сделать, например — отдать список имеющихся постов, создать новый и так далее. Действия определяются методами HTTP протокола, как уже было сказано выше. Таких действий несколько, но нас интересуют стандартные: GET, POST, PUT, DELETE.&lt;/p>
&lt;p>&lt;strong>Перейдём к самому проектированию&lt;/strong>. Разберём его по шагам:&lt;/p>
&lt;ul>
&lt;li>Перво-наперво нужно определить все ресурсы и под-ресурсы, с которыми наше API должно работать. В нашем случае это &lt;strong>Пост&lt;/strong> и &lt;strong>Комментарий&lt;/strong>.&lt;/li>
&lt;li>Далее, нужно определить набор действий, которые наше API позволяет совершать над ресурсами. Для нас это:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>GET Пост — для получения списка имеющихся постов&lt;/li>
&lt;li>POST Пост — для создания нового поста&lt;/li>
&lt;li>PUT Пост — для изменения имеющегося поста&lt;/li>
&lt;li>DELETE Пост — для удаления поста&lt;/li>
&lt;li>GET Комментарий — для получения списка комментариев поста&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Определим набор параметров для действий, которые мы спроектировали выше:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>Операция получения постов GET — может быть вызвана как без параметров, что приведёт к чтению всех имеющихся постов, так и с идентификатором конкретного поста для получения выбранного поста&lt;/li>
&lt;li>Операция создания поста POST подразумевает, что в неё будет передана информация о посте, который необходимо создать&lt;/li>
&lt;li>PUT требует двух параметров — идентификатора поста, который мы будем изменять и сам пост, который заменит имеющийся в блогосервисе&lt;/li>
&lt;li>DELETE требует идентификатора поста, который необходимо удалить&lt;/li>
&lt;li>Операция получения комментариев GET требует идентификатора поста, потому что мы хотим получить список комментариев к определённому посту&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Прервёмся на секунду&lt;/strong>. Мы провели большую подготовительную работу для сбора данных о нашем будущем API. Теперь мы знаем как конкретно и с чем конкретно наше API будет работать. Но эту информацию стоит дополнить и на следующем шаге мы займёмся именно этим.&lt;/p>
&lt;p>На какие ещё моменты нам стоит обратить внимание? Их несколько. Нужно ответить на следующие вопросы:&lt;/p>
&lt;ul>
&lt;li>Кто будет вызывать операции API?&lt;/li>
&lt;li>Что и как будет делать этот кто-то с нашим API?&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Небольшая ремарка&lt;/strong> — структура статьи на Medium не позволяет создать таблицу, хотя дальнейшую работу по проектированию нашего REST API я рекомендую проводить именно с таблицами. Поэтому дальше — мы в текстовом виде разберём что нам нужно делать, но я подразумеваю, что все моменты которые мы оговорим будут внесены в специальную таблицу.&lt;/p>
&lt;p>&lt;strong>Наша таблица проектирования — наш помощник&lt;/strong>. Список её колонок следующий:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Кто&lt;/strong> — тут могут быть роли пользователей, которые будут работать с нашим API&lt;/li>
&lt;li>&lt;strong>Что&lt;/strong> — имеется ввиду что делает пользователь с нашим API. Его ожидания&lt;/li>
&lt;li>&lt;strong>Как&lt;/strong> — опять же, как наш пользователь достигает своей цели&lt;/li>
&lt;li>&lt;strong>Входные данные&lt;/strong> — информацию, которую необходимо передать нашему API, для того, чтобы оно помогло пользователю достигнуть цели&lt;/li>
&lt;li>&lt;strong>Выходные данные&lt;/strong> — информация, которую вернёт наш API в результате работы метода&lt;/li>
&lt;li>&lt;strong>Цель&lt;/strong> — описывает явно смысл конкретной операции нашего API&lt;/li>
&lt;li>&lt;strong>HTTP метод&lt;/strong> — указание на HTTP метод, который описывает действие нашего пользователя&lt;/li>
&lt;li>&lt;strong>URI&lt;/strong> — путь по которому данная операция нашего API доступна клиентам&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/images/design-rest-api/1.png" alt="design-rest-api-table-1">&lt;/p>
&lt;p>&lt;strong>Всё что нам осталось сделать&lt;/strong>, это на основе информации, которую мы проговорили выше &lt;strong>заполнить эту табличку&lt;/strong>. Попробуем сделать это для операции получения постов:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/2.png" alt="design-rest-api-table-2">&lt;/p>
&lt;p>&lt;strong>Разберём подробнее&lt;/strong>. Раз уж мы работаем с постами, то кто-то их должен писать. Это будет Автор. Автор может получить доступ ко всем своим постам, поэтому для операции чтения постов нам не требуется никаких входных данных. Реализация самого API может установить текущего пользователя системы и определить авторство постов. На выходе же мы получим список постов, которые были написаны автором (или текущем залогиненным пользователем). Операция получения данных описывается в HTTP протоколе методом GET, а URI в конце, может иметь произвольную структуру, но общепринято в хвосте URL путь писать с указанием ресурса с которым в данном API мы работаем во множественном числе. В нашем случае это &lt;code>…/posts&lt;/code>.&lt;/p>
&lt;p>&lt;strong>По мере заполнения таблицы, всегда задаём себе вопросы&lt;/strong> — откуда берутся ресурсы, кто с ними работает и так далее. Чем шире посмотреть на имеющиеся данные, тем больше возможных кейсов можно идентифицировать на этапе проектирования. Простой пример — мы спроектировали операцию получения авторских постов. Но кто эти посты добавляет в систему? Очевидно, что авторы. Спроектируем и это:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/3.png" alt="design-rest-api-table-3">&lt;/p>
&lt;p>Пользуясь этим подходом &lt;strong>спроектируем оставшиеся операции&lt;/strong>:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/4.png" alt="design-rest-api-table-4">&lt;/p>
&lt;p>&lt;strong>Обратите внимание на последнюю строку&lt;/strong>. Мы уже коснулись темы подресурсов выше. В таблице на картинке выше Вы можете заметить как выглядит URI для доступа к комментариям поста. В пути сначала пишется родительский ресурс, а потом уже указание на подресурс: &lt;code>/api/[resource]/{id}/[sub-resource]&lt;/code>. Это общепринятая практика и подобное построение пути даёт возможность пользователям Вашего API сразу понять какие ресурсы зависят от других.&lt;/p>
&lt;p>&lt;strong>В заключение, хочется задать вопрос — Подходит ли спроектированное нами API на все случаи жизни? Конечно же — нет&lt;/strong>. Если Вы присмотритесь к таблице внимательнее, станет ясно, что это API предназначено исключительно для Авторов постов. Автор может читать только свои посты. А вот пользователи блогосервиса должны получать доступ ко всем постам всех авторов. Такие вот моменты становятся видны, если на этапе проектирования каждой из операции задавать вопросы о том, кто будет пользоваться ими и в каких случаях.&lt;/p>
&lt;p>&lt;strong>Надеюсь эта статья поможет Вам&lt;/strong> подступиться к такой огромной теме как REST API’и и направит Вас в моменты, когда придётся проектировать собственное API.&lt;/p>
&lt;h1 id="полезные-ссылки">Полезные ссылки&lt;/h1>
&lt;ul>
&lt;li>[1] Мой старый &lt;a href="https://anver-bogatov.medium.com/%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-rest-api-86b2d6737401">блог на Medium&lt;/a>&lt;/li>
&lt;li>[2] Книга &amp;ldquo;The Design of Web APIs&amp;rdquo; &lt;a href="https://www.manning.com/books/the-design-of-web-apis">на Manning&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>