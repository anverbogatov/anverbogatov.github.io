<!DOCTYPE html>
<html lang="en">
   <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Cache-control" content="public">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="hexed bits, apps, iOS, objective-c, swift, cocoa, apple, xcode, app store, software, programming, engineering, design patterns">
    <meta name="description" content="Бесконечность - не предел.">
    <meta name="author" content="Anver Bogatov">

    <title>
        
            Protocol composition in Swift and Objective-C &middot; Anver Bogatov
        
    </title>

    <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="Protocol composition in Swift and Objective-C" />
<meta name="author" content="Anver Bogatov" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Protocols in Swift and Objective-C are a powerful tool to decouple your code. They allow you to specify a contract between classes that consume them, but defer a concrete implementation to conformers. They allow you to segregate interfaces and invert control. One interesting aspect of protocols in Swift and Objective-C is that protocol members can be optional (optional in Swift or @optional in Objective-C). Unfortunately, this comes with a number of disadvantages and diminishes the robustness of your code, so it is often avoided. However, having optional members is sometimes the right conceptual model for your design. How can you design your protocols to provide optional semantics without specifying them as optional or @optional?" />
<meta property="og:description" content="Protocols in Swift and Objective-C are a powerful tool to decouple your code. They allow you to specify a contract between classes that consume them, but defer a concrete implementation to conformers. They allow you to segregate interfaces and invert control. One interesting aspect of protocols in Swift and Objective-C is that protocol members can be optional (optional in Swift or @optional in Objective-C). Unfortunately, this comes with a number of disadvantages and diminishes the robustness of your code, so it is often avoided. However, having optional members is sometimes the right conceptual model for your design. How can you design your protocols to provide optional semantics without specifying them as optional or @optional?" />
<link rel="canonical" href="http://localhost:4000/blog/protocol-composition-in-swift-and-objc/" />
<meta property="og:url" content="http://localhost:4000/blog/protocol-composition-in-swift-and-objc/" />
<meta property="og:site_name" content="Anver Bogatov" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-05T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@anver_bogatov" />
<meta name="twitter:creator" content="@anver_bogatov" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"Protocol composition in Swift and Objective-C","author":{"@type":"Person","name":"Anver Bogatov"},"datePublished":"2017-06-05T00:00:00+00:00","dateModified":"2017-06-05T00:00:00+00:00","description":"Protocols in Swift and Objective-C are a powerful tool to decouple your code. They allow you to specify a contract between classes that consume them, but defer a concrete implementation to conformers. They allow you to segregate interfaces and invert control. One interesting aspect of protocols in Swift and Objective-C is that protocol members can be optional (optional in Swift or @optional in Objective-C). Unfortunately, this comes with a number of disadvantages and diminishes the robustness of your code, so it is often avoided. However, having optional members is sometimes the right conceptual model for your design. How can you design your protocols to provide optional semantics without specifying them as optional or @optional?","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/img/logo.png"},"name":"Anver Bogatov"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/protocol-composition-in-swift-and-objc/"},"url":"http://localhost:4000/blog/protocol-composition-in-swift-and-objc/"}</script>
<!-- End Jekyll SEO tag -->


    <meta name="twitter:image" content="/img/logo.png" />
    <meta property="og:image" content="/img/logo.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="512" />
    <meta property="og:image:height" content="512" />

    <link href="/bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="/bower_components/font-awesome/css/font-awesome.min.css" rel="stylesheet">
    <link href="/bower_components/ubuntuMono/ubuntuMono.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/style.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="/bower_components/html5shiv/dist/html5shiv.min.js"></script>
      <script src="/bower_components/respond/dest/respond.min.js"></script>
    <![endif]-->

    <link rel="apple-touch-icon" sizes="76x76" href="/ico/icon76.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/ico/icon120.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/ico/icon152.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/ico/icon167.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/ico/icon180.png">

    <link rel="shortcut icon" href="/favicon.ico">
    <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Anver Bogatov" />

    <script>
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
         (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
         m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
         ga('create', 'UA-37319916-5', 'auto');
         ga('send', 'pageview');
    </script>
</head>

   <body>
      
<header class="container container-fluid">
   <div class="row">
      <div class="col-md-12 col-sm-12 col-xs-12">
        <h1 class="text-center"><a href="/">Anver Bogatov</a></h1>
        <div class="col-md-12 col-sm-12 col-xs-12">
            <h2 class="tagline">&mdash; Бесконечность - не предел. &mdash;</h2>
         </div> <!-- col -->
      </div> <!-- col -->
   </div> <!-- row -->

   <div class="row menu">
      <div class="col-md-12 col-sm-12 col-xs-12">
         <a class="btn btn-default" href="/">Блог</a>
         <!-- <a class="btn btn-default" href="/speaking/">Speaking</a> -->
         <a class="btn btn-default" href="/about/">Обо мне</a>
      </div> <!-- col -->
   </div> <!-- row -->
   <hr>
</header>


      <div class="container container-fluid">
         <div class="row">
            <div class="col-sm-12 col-sm-offset-0 col-md-10 col-md-offset-1">
               <article>
   <h1 class="post-title"><a href="">Protocol composition in Swift and Objective-C</a></h1>
   <h2 class="post-subtitle">Designing optional semantics without optional methods <small class="post-date">05 Jun 2017</small></h2>
   

   <div class="post-content">
      <p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Protocol.html">Protocols</a> in Swift and Objective-C are a powerful tool to decouple your code. They allow you to specify a contract between classes that consume them, but defer a concrete implementation to conformers. They allow you to <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">segregate interfaces</a> and <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">invert control</a>. One interesting aspect of protocols in Swift and Objective-C is that protocol members can be <em>optional</em> (<code class="highlighter-rouge">optional</code> in Swift or <code class="highlighter-rouge">@optional</code> in Objective-C). Unfortunately, this comes with a number of disadvantages and diminishes the robustness of your code, so it is often avoided. However, having optional members is sometimes the right conceptual model for your design. How can you design your protocols to provide optional semantics without specifying them as <code class="highlighter-rouge">optional</code> or <code class="highlighter-rouge">@optional</code>?</p>

<!--excerpt-->

<h3 id="the-problem-with-optional">The problem with <code class="highlighter-rouge">@optional</code></h3>

<p>Let’s begin with Objective-C. Optional protocol methods were introduced in Objective-C 2.0 and are used heavily in Cocoa and Cocoa Touch. You implement protocols with optional methods all the time while working with UIKit, for example. But despite their prevalence, they are widely discouraged and considered a poor design. This is because you forgo compile-time checks for <code class="highlighter-rouge">@optional</code> protocol methods in Objective-C. If a method is optional, then the compiler has no way to enforce that the conformers implement it. On the other hand, it is an error if you declare protocol conformance but fail to implement the required methods. Thus, it is the <em>caller’s responsibility</em> to check <a href="https://developer.apple.com/reference/objectivec/1418956-nsobject/1418583-respondstoselector"><code class="highlighter-rouge">-respondsToSelector:</code></a> before calling an optional method. If you forget this check and the class does not implement the optional method, you’ll crash at runtime with a ‘does not respond to selector’ exception.</p>

<p>Consider the following example:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@protocol</span> <span class="nc">MyViewControllerDelegate</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">didDismissController</span><span class="o">:</span><span class="p">(</span><span class="n">MyViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">controller</span><span class="p">;</span>

<span class="k">@optional</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">controller</span><span class="o">:</span><span class="p">(</span><span class="n">MyViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">controller</span> <span class="n">didSelectItem</span><span class="o">:</span><span class="p">(</span><span class="n">MyItem</span> <span class="o">*</span><span class="p">)</span><span class="n">item</span><span class="p">;</span>

<span class="k">@end</span>


<span class="k">@interface</span> <span class="nc">MyViewController</span> <span class="p">:</span> <span class="nc">UIViewController</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">id</span><span class="o">&lt;</span><span class="n">MyViewControllerDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>

<span class="k">@end</span></code></pre></figure>

<p>Calling required methods on the <code class="highlighter-rouge">delegate</code> is straightforward:</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nf">didDismissController</span><span class="p">:</span><span class="n">self</span><span class="p">];</span></code></pre></figure>

<p>With optional methods, not only do you forgo help from the compiler, but you incur the additional runtime cost of checking <code class="highlighter-rouge">-respondsToSelector:</code> every time you need to message the <code class="highlighter-rouge">delegate</code> object.</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">if</span> <span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nf">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">controller</span><span class="p">:</span><span class="n">didSelectItem</span><span class="o">:</span><span class="p">)])</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nf">controller</span><span class="p">:</span><span class="n">self</span> <span class="nf">didSelectItem</span><span class="p">:</span><span class="n">item</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<h3 id="the-problem-with-optional-1">The problem with <code class="highlighter-rouge">optional</code></h3>

<p>Swift addresses the safety problems above and offers a convenient <code class="highlighter-rouge">?</code> syntax for optional members:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">controller</span><span class="p">?(</span><span class="k">self</span><span class="p">,</span> <span class="nv">didSelect</span><span class="p">:</span> <span class="n">item</span><span class="p">)</span></code></pre></figure>

<p>In this case, you do not have to worry about runtime crashes in Swift, but there is another problem. In Swift, <code class="highlighter-rouge">optional</code> is <em>not really</em> “part of the language” or “pure Swift” — the feature relies on the Objective-C runtime and <strong>it only exists for interoperability with Objective-C</strong>. Any protocol in Swift that contains optional members must be marked as <code class="highlighter-rouge">@objc</code>. I have <a href="/avoiding-objc-in-swift/">written before</a> about avoiding <code class="highlighter-rouge">@objc</code> in your Swift code as much as possible. When <code class="highlighter-rouge">@objc</code> infiltrates your object graph, nearly everything must inherit from <code class="highlighter-rouge">NSObject</code> which means you cannot use Swift structs, enums, or other nice features. This leaves you not writing Swift, but merely “Objective-C with a new syntax”. Clearly, <code class="highlighter-rouge">optional</code> isn’t much of an option in Swift.</p>

<h3 id="the-never-optional-solution">The ‘never optional’ solution</h3>

<p>One naive solution is to simply never use <code class="highlighter-rouge">optional</code> or <code class="highlighter-rouge">@optional</code>. This is easy and straightforward. It’s great for simple cases. You provide a strict contract and avoid the shortcomings mentioned above, but in many cases this places an unnecessary burden on classes that conform to the protocol. You end up with a slew of empty methods, or methods that return sentinel values like <code class="highlighter-rouge">nil</code>, <code class="highlighter-rouge">-1</code>, or <code class="highlighter-rouge">false</code>. Consider the familiar <a href="https://developer.apple.com/reference/uikit/uitableviewdatasource"><code class="highlighter-rouge">UITableViewDataSource</code></a> protocol. It has two required methods and <strong>nine</strong> optional methods. Imagine if these were all <code class="highlighter-rouge">@required</code> but you wanted to opt-out of those behaviors. You would have nine empty method stubs, or you would have to return <code class="highlighter-rouge">nil</code> for methods like <a href="https://developer.apple.com/reference/uikit/uitableviewdatasource/1614850-tableview"><code class="highlighter-rouge">tableView(_: titleForHeaderInSection:) -&gt; String?</code></a>.</p>

<h3 id="using-multiple-protocols-and-properties">Using multiple protocols and properties</h3>

<p>A better approach is to split up large protocols into smaller ones, and provide a unique property (like a delegate) for each one. Again, consider <a href="https://developer.apple.com/reference/uikit/uitableviewdatasource"><code class="highlighter-rouge">UITableViewDataSource</code></a>. There are clear semantic groupings for these methods. It could easily be broken up into multiple protocols and <code class="highlighter-rouge">UITableView</code> could have a property for each one. Ash Furrow <a href="https://ashfurrow.com/blog/protocols-and-swift/">has a great article</a> on doing exactly that. Thus, we could reimagine these APIs in the following way:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">TableView</span> <span class="p">{</span>
    <span class="k">weak</span> <span class="k">var</span> <span class="nv">dataSource</span><span class="p">:</span> <span class="kt">TableViewDataSource</span><span class="p">?</span>
    <span class="k">weak</span> <span class="k">var</span> <span class="nv">titlesDataSource</span><span class="p">:</span> <span class="kt">TableViewTitlesDataSource</span><span class="p">?</span>
    <span class="k">weak</span> <span class="k">var</span> <span class="nv">reorderingDataSource</span><span class="p">:</span> <span class="kt">TableViewReorderingDataSource</span><span class="p">?</span>

    <span class="c1">// And so on...</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">TableViewDataSource</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">numberOfSections</span><span class="p">(</span><span class="k">in</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">cellForRowAtIndexPath</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TableViewCell</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">TableViewTitlesDataSource</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">titleForHeaderInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">titleForFooterInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">TableViewReorderingDataSource</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">canMoveRowAtIndexPath</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">moveRowAtIndexPath</span> <span class="nv">sourceIndexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span> <span class="n">toIndexPath</span> <span class="nv">destinationIndexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// And so on...</span></code></pre></figure>

<p>This design transfers the “optional-ness” from the protocol itself to an additional optional property on the class. If you want headers and footers in your table view, you can opt-in to those by setting <code class="highlighter-rouge">titlesDataSource</code>. To opt-out, you can set this property to <code class="highlighter-rouge">nil</code>. The same applies to <code class="highlighter-rouge">reorderingDataSource</code>, and so on. This design feels appropriate for <code class="highlighter-rouge">UITableView</code> at first. Many of the methods are not directly related to one another and there are clear semantic groupings. In practice, however, it feels awkward having to access multiple separate properties to query the same underlying data source.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// access sections via `dataSource`</span>
<span class="k">let</span> <span class="nv">sections</span> <span class="o">=</span> <span class="n">dataSource</span><span class="p">?</span><span class="o">.</span><span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">numberOfRowsInSection</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">// access titles via `titlesDataSource`</span>
<span class="k">let</span> <span class="nv">headerTitle</span> <span class="o">=</span> <span class="n">titlesDataSource</span><span class="p">?</span><span class="o">.</span><span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">titleForHeaderInSection</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">// access reordering via `reorderingDataSource`</span>
<span class="k">let</span> <span class="nv">canMove</span> <span class="o">=</span> <span class="n">reorderingDataSource</span><span class="p">?</span><span class="o">.</span><span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">canMoveRowAtIndexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">section</span><span class="p">:</span> <span class="mi">0</span><span class="p">))</span></code></pre></figure>

<p>Having these disjoint protocols and properties is not desirable. Despite having nice semantic groupings, all of these methods <em>are related</em> in the sense that they all need access to <em>the same underlying data</em> in order to work properly together. To accommodate the complete <code class="highlighter-rouge">UITableViewDataSource</code> protocol, there would be five distinct protocols, each with a corresponding property on <code class="highlighter-rouge">UITableView</code>. Then you could reorganize the <a href="https://developer.apple.com/reference/uikit/uitableviewdelegate"><code class="highlighter-rouge">UITableViewDelegate</code></a> protocol in the same way, which would have at least 10 protocols and properties. Having this many <code class="highlighter-rouge">dataSource</code> and <code class="highlighter-rouge">delegate</code> properties is unintuitive and cumbersome. How can we improve this?</p>

<h3 id="composing-protocols">Composing protocols</h3>

<p>Instead of numerous disjoint protocols, you can design a union of protocols. This provides a single, top-level “entry point” to reference. You can extract the optional members of a protocol into a new protocol, then add an optional property for this new protocol on the original protocol. The result is a comprehensive top-level protocol and a set of “nested” protocols.</p>

<p>Adjusting the table view example above:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">TableView</span> <span class="p">{</span>
    <span class="k">weak</span> <span class="k">var</span> <span class="nv">dataSource</span><span class="p">:</span> <span class="kt">TableViewDataSource</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">TableViewDataSource</span><span class="p">:</span> <span class="kd">class</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">numberOfSections</span><span class="p">(</span><span class="k">in</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">cellForRowAtIndexPath</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TableViewCell</span>

    <span class="k">var</span> <span class="nv">titles</span><span class="p">:</span> <span class="kt">TableViewTitlesDataSource</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">reordering</span><span class="p">:</span> <span class="kt">TableViewReorderingDataSource</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// And so on...</span></code></pre></figure>

<p>Now the table view has a single <code class="highlighter-rouge">dataSource</code> property. The other protocols still exist, but they are absorbed into the <code class="highlighter-rouge">titles</code> and <code class="highlighter-rouge">reordering</code> properties. Another positive aspect of this design is that the opt-in/opt-out behavior for the nested protocols is explicitly declared. The conformer to <code class="highlighter-rouge">TableViewDataSource</code> can return <code class="highlighter-rouge">nil</code> to opt-out or return <code class="highlighter-rouge">self</code> to opt-in to these additional methods.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">MyDataSource</span><span class="p">:</span> <span class="kt">TableViewDataSource</span><span class="p">,</span> <span class="kt">TableViewTitlesDataSource</span> <span class="p">{</span>

    <span class="kd">func</span> <span class="nf">numberOfSections</span><span class="p">(</span><span class="k">in</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="c1">// return sections</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="c1">// return rows per section</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">cellForRowAtIndexPath</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TableViewCell</span> <span class="p">{</span>
        <span class="c1">// configure and return a cell</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">titles</span><span class="p">:</span> <span class="kt">TableViewTitlesDataSource</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// opt-in to headers and footers</span>
        <span class="k">return</span> <span class="k">self</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">titleForHeaderInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// return header title</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">TableView</span><span class="p">,</span> <span class="n">titleForFooterInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// return footer title</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">reordering</span><span class="p">:</span> <span class="kt">TableViewReorderingDataSource</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// opt-out of reordering</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Accessing these nested members goes through a single point of access:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">sections</span> <span class="o">=</span> <span class="n">dataSource</span><span class="p">?</span><span class="o">.</span><span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">numberOfRowsInSection</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">headerTitle</span> <span class="o">=</span> <span class="n">dataSource</span><span class="p">?</span><span class="o">.</span><span class="n">titles</span><span class="p">?</span><span class="o">.</span><span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">titleForHeaderInSection</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">canMove</span> <span class="o">=</span> <span class="n">dataSource</span><span class="p">?</span><span class="o">.</span><span class="n">reordering</span><span class="p">?</span><span class="o">.</span><span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">canMoveRowAtIndexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">(</span><span class="nv">row</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">section</span><span class="p">:</span> <span class="mi">0</span><span class="p">))</span></code></pre></figure>

<p>This reduces the API surface area of <code class="highlighter-rouge">UITableView</code> by only having a single <code class="highlighter-rouge">dataSource</code> property instead of five — not to mention the 10 potential <code class="highlighter-rouge">delegate</code> properties there could have been after splitting up <code class="highlighter-rouge">UITableViewDelegate</code>. It unifies all of the methods of the data source protocol without resorting to using <code class="highlighter-rouge">optional</code>, while allowing you to opt out of the additional behavior in a concise way. In the case of Objective-C, the check for <code class="highlighter-rouge">-respondsToSelector:</code> becomes a simple check for <code class="highlighter-rouge">nil</code> instead, and the compiler can enforce that the entire protocol is implemented. Overall, it feels cleaner and much more cohesive, especially at the call site.</p>

<p><strong>UPDATE:</strong>  <a href="https://twitter.com/IanKay/status/871773445373149184">@IanKay</a> pointed out that you <a href="https://gist.github.com/IanKeen/68eba888221a1a8de03dbbdd8a4dfcf1">can further reduce boilerplate</a> from the child protocols by using protocol extensions. For example:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">TableViewDataSource</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">titles</span><span class="p">:</span> <span class="kt">TableViewTitlesDataSource</span><span class="p">?</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">reordering</span><span class="p">:</span> <span class="kt">TableViewReorderingDataSource</span><span class="p">?</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>See <a href="https://gist.github.com/IanKeen/68eba888221a1a8de03dbbdd8a4dfcf1">the full gist</a> for more details.</p>

<h3 id="conclusion">Conclusion</h3>

<p>As we’ve explored, there are a number of ways to design a solution to the “optional protocol problem”. You can design a model that avoids optionality altogether, you can provide many protocols with corresponding properties, or you can design a “nested composition” of protocols. Every situation is different, but I often find this nested composition approach to be the most elegant, powerful, and intuitive.</p>

   </div> <!-- post-content -->
</article>


<div class="post-share-subscribe">
   <div class="row">
      <div class="col-md-6 col-sm-6 col-xs-12 center">
         <div class="btn-group btn-group-justified" role="group">

            <div class="btn-group dropup" role="group">
               <button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  Share &nbsp;<i class="fa fa-share-alt" aria-hidden="true"></i>
               </button>
               <ul class="dropdown-menu">
                  <li>
                     <a href="https://twitter.com/intent/tweet?text=Protocol%20composition%20in%20Swift%20and%20Objective-C%20http://localhost:4000/blog/protocol-composition-in-swift-and-objc/%20via%20@anver_bogatov" title="Tweet" target="_blank">
                     Twitter &nbsp;<i class="fa fa-twitter" aria-hidden="true"></i>
                     </a>
                  </li>
                  <li>
                     <a href="https://www.facebook.com/sharer.php?u=http://localhost:4000/blog/protocol-composition-in-swift-and-objc/" title="Post" target="_blank">
                     Facebook &nbsp;<i class="fa fa-facebook" aria-hidden="true"></i>
                     </a>
                  </li>
                  <li>
                     <a href="https://plus.google.com/share?url=http://localhost:4000/blog/protocol-composition-in-swift-and-objc/" title="Share" target="_blank">
                     Google &nbsp;<i class="fa fa-google-plus" aria-hidden="true"></i>
                     </a>
                  </li>
               </ul>
            </div> <!-- share dropup -->

            <div class="btn-group dropup" role="group">
               <button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  Subscribe &nbsp;<i class="fa fa-rss" aria-hidden="true"></i>
               </button>
               <ul class="dropdown-menu">
                  <li><a href="/feed.xml" title="Subscribe via RSS/atom">RSS/Atom &nbsp;<i class="fa fa-rss" aria-hidden="true"></i></a></li>
                  <li><a href="" title="Add to Apple News">Apple News &nbsp;<i class="fa fa-apple" aria-hidden="true"></i></a></li>
               </ul>
            </div> <!-- subscribe drop-up -->

            <div class="btn-group dropup" role="group">
               <button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  Support &nbsp;<i class="fa fa-star" aria-hidden="true"></i>
               </button>
               <ul class="dropdown-menu">
                  <li><a href="" title="Donate via PayPal" target="_blank">Donate via PayPal &nbsp;<i class="fa fa-paypal" aria-hidden="true"></i></a></li>
                  <li><a href="" title="Donate via Square Cash" target="_blank">Donate via Square &nbsp;<i class="fa fa-dollar" aria-hidden="true"></i></a></li>
                  <li><a href="" title="Donate Bitcoin" target="_blank">Donate Bitcoin &nbsp;<i class="fa fa-btc" aria-hidden="true"></i></a></li>
               </ul>
            </div> <!-- donate drop-up -->

         </div> <!-- btn-group -->
      </div> <!-- col -->
   </div> <!-- row -->

   <div class="row feedback">
      <div class="col-md-6 col-sm-6 col-xs-12 center">
         <p class="text-muted text-center"><small><b>Questions? Feedback? Corrections?</b></small></p>
         <p class="text-muted text-center"><small>
         Open an <a href="https://github.com/anverbogatov/anverbogatov.github.io/issues/new" target="_blank">issue</a> or
         submit a <a href="https://github.com/anverbogatov/anverbogatov.github.io/compare" target="_blank">pull request</a>.
         </small></p>
      </div> <!-- col -->
   </div> <!-- row -->

</div> <!-- post-share-subscribe -->


            </div> <!-- col -->
         </div> <!-- row -->
      </div> <!-- container -->

      
<footer class="container container-fluid">
   <hr>

   <div class="row contact">
    <div class="col-sm-12 col-sm-offset-0 col-md-8 col-md-offset-2">
        <ul class="inline center">
            <li><a href="https://github.com/anverbogatov" title="Ищи меня на Github"><i class="fa fa-2x fa-github" aria-hidden="true"></i></a></li>
            <li><a href="https://twitter.com/anver_bogatov" title="Ищи меня в Twitter"><i class="fa fa-2x fa-twitter" aria-hidden="true"></i></a></li>
            <li><a href="https://www.linkedin.com/in/anver-bogatov-64b32661/" title="Свяжись со мной в LinkedIn"><i class="fa fa-2x fa-linkedin" aria-hidden="true"></i></a></li>
            <li><a href="/feed.xml" title="Подпишись с помощью RSS/atom"><i class="fa fa-2x fa-rss-square" aria-hidden="true"></i></a></li>
        </ul>
    </div> <!-- col -->
</div> <!-- row -->


   <p class="text-muted text-center"><small>
   &copy; 2017 Anver Bogatov.
   This site is <a href="https://github.com/anverbogatov/anverbogatov.github.io">open source</a>.
   </small></p>
</footer>

      
<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>

   </body>
</html>
