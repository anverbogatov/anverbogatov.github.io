<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hibernate on Anver Bogatov</title><link>/ru/tags/hibernate/</link><description>Recent content in hibernate on Anver Bogatov</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 10 Nov 2021 19:51:58 +0400</lastBuildDate><atom:link href="/ru/tags/hibernate/index.xml" rel="self" type="application/rss+xml"/><item><title>Hibernate N+1 Проблема</title><link>/ru/posts/hibernate-n1-problem/</link><pubDate>Wed, 10 Nov 2021 19:51:58 +0400</pubDate><guid>/ru/posts/hibernate-n1-problem/</guid><description>Пример N+1 проблемы Проще всего проблему проиллюстрировать используя классический пример с Книгой (book) и Автором (author). Предположим, что у нас в модели есть сущность Book. У каждой сущности Book есть свой Author.
В Java, с использованием Hibernate это отношение можно смоделировать следующим образом:
@Data @Entity @Table(name = &amp;#34;book&amp;#34;) public class Book { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private int id; private String title; @OneToOne(fetch = FetchType.LAZY) private Author author; } ---------------------------------------------------------- @Data @Entity @Table(name = &amp;#34;author&amp;#34;) public class Author { @Id @GeneratedValue(strategy = GenerationType.</description><content>&lt;h3 id="пример-n1-проблемы">Пример N+1 проблемы&lt;/h3>
&lt;p>Проще всего проблему проиллюстрировать используя классический пример с Книгой (book) и Автором (author). Предположим, что у нас в модели есть сущность Book. У каждой сущности Book есть свой Author.&lt;/p>
&lt;p>В Java, с использованием Hibernate это отношение можно смоделировать следующим образом:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;span style="color:#a6e22e">@Entity&lt;/span>
&lt;span style="color:#a6e22e">@Table&lt;/span>&lt;span style="color:#f92672">(&lt;/span>name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;book&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Book&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#a6e22e">@Id&lt;/span>
&lt;span style="color:#a6e22e">@GeneratedValue&lt;/span>&lt;span style="color:#f92672">(&lt;/span>strategy &lt;span style="color:#f92672">=&lt;/span> GenerationType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">SEQUENCE&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> String title&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@OneToOne&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fetch &lt;span style="color:#f92672">=&lt;/span> FetchType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">LAZY&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> Author author&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">----------------------------------------------------------&lt;/span>
&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;span style="color:#a6e22e">@Entity&lt;/span>
&lt;span style="color:#a6e22e">@Table&lt;/span>&lt;span style="color:#f92672">(&lt;/span>name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;author&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Author&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#a6e22e">@Id&lt;/span>
&lt;span style="color:#a6e22e">@GeneratedValue&lt;/span>&lt;span style="color:#f92672">(&lt;/span>strategy &lt;span style="color:#f92672">=&lt;/span> GenerationType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">SEQUENCE&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> String name&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@OneToOne&lt;/span>&lt;span style="color:#f92672">(&lt;/span>mappedBy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;author&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> Book book&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Поле &lt;code>book&lt;/code> в классе &lt;code>Author&lt;/code> указывает на то, что владельцем отношения является сущность &lt;code>Book&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java"> &lt;span style="color:#a6e22e">@OneToOne&lt;/span>&lt;span style="color:#f92672">(&lt;/span>mappedBy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;author&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> Book book&lt;span style="color:#f92672">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Предположим, что нам необходимо загрузить из базы данных несколько книг. Для доступа к базе данных, мы используем простейший Spring Repository:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">BookRepository&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> CrudRepository&lt;span style="color:#f92672">&amp;lt;&lt;/span>Book&lt;span style="color:#f92672">,&lt;/span> Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>C репозиторием, подобному тому, что Я привожу выше, уже можно зачитать из базы данных все сохранённые Книги (book). Сделать это можно, просто вызвав следующий метод:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">repository&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">findAll&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>При наличии следующей конфигурации:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">spring&lt;/span>:
&lt;span style="color:#f92672">jpa&lt;/span>:
&lt;span style="color:#f92672">show-sql&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>В логах приложения мы увидим:&lt;/p>
&lt;pre>&lt;code class="language-logs" data-lang="logs">Hibernate: select book0_.id as id1_1_, book0_.author_id as author_i3_1_, book0_.title as title2_1_ from book book0_
Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_
from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id=?
Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_
from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id=?
Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_
from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id=?
&lt;/code>&lt;/pre>&lt;p>Разберём подробнее, что же в мы тут видим.&lt;/p>
&lt;p>Первый запрос:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sql" data-lang="sql">&lt;span style="color:#66d9ef">select&lt;/span> book0_.id &lt;span style="color:#66d9ef">as&lt;/span> id1_1_, book0_.author_id &lt;span style="color:#66d9ef">as&lt;/span> author_i3_1_, book0_.title &lt;span style="color:#66d9ef">as&lt;/span> title2_1_ &lt;span style="color:#66d9ef">from&lt;/span> book book0_
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Зачитывает все имеющиеся записи в таблице &lt;code>book&lt;/code>. Для своего эксперимента Я сохранил 3 сущности типа Book. У каждой из этих сущностей, был установлен свой, уникальный автор - Author. Итого, в базе данных сохранено 3 записи в таблице &lt;code>book&lt;/code> и 3 записи в таблице &lt;code>author&lt;/code>.&lt;/p>
&lt;p>После того, как Hibernate зачитал все имеющиеся книги одним запросом, он начал зачитывать записи из таблицы с авторами по одному, с использованием outer join конструкции.&lt;/p>
&lt;p>Это и есть проблема - N+1.&lt;/p>
&lt;h3 id="что-такое-n1">Что такое N+1?&lt;/h3>
&lt;p>Проблема N+1 - это проблема неоптимального доступа к сохранённым данным, при которой каждой из записей зачитанных одним sql запросом связные данные будут зачитаны по одному.&lt;/p>
&lt;p>N+1 можно так же расшифровать как - один запрос, чтобы зачитать множество сущностей одного типа, но N запросов, чтобы зачитать все связные сущности.&lt;/p>
&lt;h3 id="почему-это-происходит">Почему это происходит?&lt;/h3>
&lt;p>Потому что, в момент когда мы используем репозиторий для загрузки всех сущностей типа &lt;code>Book&lt;/code>, мы не сообщаем о том, что нам так же нужны связные сущности типа &lt;code>Author&lt;/code>.&lt;/p>
&lt;p>Запрос за каждой связной сущностью &lt;code>Author&lt;/code> происходит в момент доступа к ней, через поле &lt;code>author&lt;/code> объектов типа &lt;code>Book&lt;/code>.&lt;/p>
&lt;h3 id="как-обойти-проблему">Как обойти проблему?&lt;/h3>
&lt;p>Обойти проблему можно используя нативную фичу Hibernate под названием «Batch Fetching» (пакетная выборка).&lt;/p>
&lt;p>Достаточно добавить следующую аннотацию на объявление класса сущности &lt;code>Author&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@BatchSize&lt;/span>&lt;span style="color:#f92672">(&lt;/span>size &lt;span style="color:#f92672">=&lt;/span> 100&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>И запросы в логах будут выглядеть следующим образом:&lt;/p>
&lt;pre>&lt;code class="language-logs" data-lang="logs">Hibernate: select book0_.id as id1_1_, book0_.author_id as author_i3_1_, book0_.title as title2_1_ from book book0_
Hibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, book1_.id as id1_1_1_, book1_.author_id as author_i3_1_1_, book1_.title as title2_1_1_ from author author0_ left outer join book book1_ on author0_.id=book1_.author_id where author0_.id in (?, ?, ?)
&lt;/code>&lt;/pre>&lt;p>Первый запрос зачитает все записи из таблицы &lt;code>book&lt;/code>, а второй запрос зачитает все связные записи из таблицы &lt;code>author&lt;/code>.&lt;/p>
&lt;h3 id="полезные-материалы">Полезные материалы&lt;/h3>
&lt;ul>
&lt;li>[1] &lt;a href="https://github.com/anverbogatov/hibernate-n1-problem">GitHub - anverbogatov/hibernate-n1-problem: This repository contains simple Spring Boot application that is intended to illustrate N+1 problem in Hibernate.&lt;/a> - полный код приложения, которое Я написал, чтобы продемонстрировать проблему&lt;/li>
&lt;li>[2] &lt;a href="https://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html_single/#performance-fetching-batch">HIBERNATE - Relational Persistence for Idiomatic Java&lt;/a> - документация о пакетной выборке данных в Hibernate&lt;/li>
&lt;/ul></content></item></channel></rss>