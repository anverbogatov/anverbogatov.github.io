<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>design on Anver Bogatov</title><link>/ru/tags/design/</link><description>Recent content in design on Anver Bogatov</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 25 Oct 2021 19:59:56 +0400</lastBuildDate><atom:link href="/ru/tags/design/index.xml" rel="self" type="application/rss+xml"/><item><title>User Story Mapping или Карты Пользовательских Сценариев</title><link>/ru/posts/user-story-mapping/</link><pubDate>Mon, 25 Oct 2021 19:59:56 +0400</pubDate><guid>/ru/posts/user-story-mapping/</guid><description>Что такое User Story Mapping? User Story Mapping или КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ - это способ визуального планирования и приоритизации задач. Способ хорош тем, что заставляет нас думать о своих software решениях с позиции ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ (User Story).
Прежде чем мы перейдём к знакомству с методом, важно разобраться с тем, а что такое вообще ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ.
Что такое User Story? ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ - это описание какой-либо фичи продукта, рассказанное с точки зрения её пользователя.</description><content>&lt;h3 id="что-такое-user-story-mapping">Что такое User Story Mapping?&lt;/h3>
&lt;p>User Story Mapping или &lt;strong>КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> - это способ визуального планирования и приоритизации задач. Способ хорош тем, что заставляет нас думать о своих software решениях с позиции &lt;strong>ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> (User Story).&lt;/p>
&lt;p>Прежде чем мы перейдём к знакомству с методом, важно разобраться с тем, а что такое вообще &lt;strong>ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ&lt;/strong>.&lt;/p>
&lt;h3 id="что-такое-user-story">Что такое User Story?&lt;/h3>
&lt;p>&lt;strong>ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ&lt;/strong> - это описание какой-либо фичи продукта, рассказанное с точки зрения её пользователя. Буквально рассказ о том, как именно фича используется конкретным пользователем. &lt;strong>ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ&lt;/strong> при описании функционала software продукта, ставят во главу угла именно пользователя.&lt;/p>
&lt;p>При написании &lt;strong>ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> зачастую используется следующая схема:&lt;/p>
&lt;pre>&lt;code>As a [type of user],
I want [some particular feature],
So that [some benefit] is received.
&lt;/code>&lt;/pre>&lt;p>На русском, эта схема будет выглядеть следующим образом:&lt;/p>
&lt;pre>&lt;code>Как [тип пользователя],
Я хочу [описание какого-то действия],
Чтобы [описание цели].
&lt;/code>&lt;/pre>&lt;p>При составлении &lt;strong>ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> важно понимать какой уровень детализации Вам необходим. Например, следующая история это плохой пример:&lt;/p>
&lt;pre>&lt;code>Как клиент онлайн магазина,
Я хочу купить товар,
Чтобы им пользоваться.
&lt;/code>&lt;/pre>&lt;p>Почему это пример плох? Давайте закроем глаза на то, что пример взял из головы и описание цели странноватое. Главная проблема этого примера в том, что «хочу купить товар» это слишком большое действие, чтобы описывать его одной историей. «Купить товар» обычно подразумевает:&lt;/p>
&lt;ul>
&lt;li>открыть сайт онлайн магазина&lt;/li>
&lt;li>найти нужный товар&lt;/li>
&lt;li>просмотреть его характеристики&lt;/li>
&lt;li>прочитать отзывы на него&lt;/li>
&lt;li>добавить его в корзину&lt;/li>
&lt;li>залогиниться для сохранения истории покупок&lt;/li>
&lt;li>ввести данные банковской карты&lt;/li>
&lt;li>оплатить&lt;/li>
&lt;/ul>
&lt;p>Почему важно подобрать удобный уровень детализации &lt;strong>ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ&lt;/strong>? Потому что основная польза метода &lt;strong>КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> заключается в планировании доставки функционала небольшими частями. Это позволяет от одного небольшого релиза к другому, этакими частыми шажками, придти к конечной цели пользователя, реализованной в виде software решения.&lt;/p>
&lt;p>Огромные истории крайне трудно планировать, поскольку, из-за своего размера они сразу займут много времени и частичную их доставку запланировать будет проблематично. Поэтому хорошей практикой будет разбивать большие задачи, на отдельные истории. Выше я уже привёл список действий, которые входят в состав действия «Купить товар». Каждое их этих мелких действий будет отдельной историей.&lt;/p>
&lt;h3 id="как-выглядит-user-story-mapping">Как выглядит User Story Mapping?&lt;/h3>
&lt;p>Итак, теперь, когда мы разобрались с тем, что такое &lt;strong>ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ&lt;/strong>, самое время разобраться с методологией, которая их активно использует.&lt;/p>
&lt;p>Итак, попробуем составить свою &lt;strong>КАРТУ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong>. И для этого, в первую очередь нужно понять какую именно фичу мы будем моделировать. Раз уж мы заговорили про покупку товара в онлайн магазине, давайте продолжим этот пример.&lt;/p>
&lt;p>&lt;strong>КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong>, это метод визуального моделирования и планирования, поэтому для визуализации моей истории, я буду использовать сервис Miro (&lt;a href="https://miro.com">Online Whiteboard &amp;amp; Visual Collaboration Platform | Miro&lt;/a>).&lt;/p>
&lt;p>История состоит из нескольких шагов, выполняемых пользователем в определённой последовательности. Поэтому на нашу электронную доску, первым делом мы добавим нашего пользователя.&lt;/p>
&lt;p>&lt;img src="/images/user-story-mapping/1.png" alt="user-story-mapping-user">&lt;/p>
&lt;p>Для чего это нужно? Как уже было сказано выше, &lt;strong>ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ&lt;/strong> - это ориентированный на пользователя (user-centric) подход. Поэтому при моделировании историй, нужно всегда держать в голове от лица кого эта история
рассказывается.&lt;/p>
&lt;h4 id="каркас">Каркас&lt;/h4>
&lt;p>Далее, для того чтобы наша история стала похожа на осмысленный нарратив, нам нужно рассказать что и в какой последовательности делает наш пользователь. Для этого, основные действия в истории пользователя мы добавим в виде отдельных стикеров и расположим их в порядке их выполнения, слева-направо.&lt;/p>
&lt;p>&lt;img src="/images/user-story-mapping/2.png" alt="user-story-mapping-backbone">&lt;/p>
&lt;p>У нас получился список мелких целей, которые пользователь пытается достичь на каждом этапе. Если мы попытаемся рассказать историю, нарратив, используя эти карточки в качестве подсказок, то у нас это легко получиться. Это будет история про то, как Клиент онлайн магазина заказывает товар. В этом и есть &lt;strong>ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ&lt;/strong>. Однако, &lt;strong>КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> на этом не заканчивается.&lt;/p>
&lt;p>То, что мы только что сделали, этот набор стикеров, из которых состоит наша история, называется &lt;strong>КАРКАС&lt;/strong> (или Backbone, в зарубежной литературе). Именно он является основой &lt;strong>ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ&lt;/strong>, и именно на него мы будем наслаивать остальные элементы, а именно генерировать мелкие истории в формате задач, а так же выделять части чего-то единого.&lt;/p>
&lt;p>Следующим шагом, давайте посмотрим на оранжевые стикеры. Несмотря на то, что каждый из них описывает свой уникальный шаг пользователя на пути к конечной цели, есть в них и общие элементы. Например, «Ввести данные банковской карты» и «Произвести оплату заказа» относятся к более крупному действию, а именно - «Оплата товара».&lt;/p>
&lt;p>Ещё один нюанс, о котором я сразу хочу упомянуть - &lt;strong>КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> должен являться живым документом. Его содержимое должно обсуждаться, меняться и поддерживаться в актуальном состоянии. Это абсолютно нормально, работать над ним итеративно, меняя его содержимое и порядок операций для того, чтобы отразить видение того, как именно должен пройти путь пользователя через наше software решение, прежде, чем он достигнет конечного результата.&lt;/p>
&lt;p>Итак, после очередной итерации, наша карта стала выглядеть следующим образом:&lt;/p>
&lt;p>&lt;img src="/images/user-story-mapping/3.png" alt="user-story-mapping-iteration">&lt;/p>
&lt;p>Внимательный читатель заметит, что на карте появились голубые стикеры, которые отображают более общие шаги и называются &lt;strong>АКТИВНОСТЯМИ&lt;/strong>, а так же, поменялся порядок некоторых оранжевых стикеров.&lt;/p>
&lt;p>Но и это ещё не всё. Пока мы просто организуем наше представление о действиях пользователя. Мы прописываем саму историю. Однако, поскольку &lt;strong>КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> является ещё и инструментом планирования задач, самое время про это и поговорить.&lt;/p>
&lt;h4 id="задачи">Задачи&lt;/h4>
&lt;p>Каждый из оранжевых стикеров описывает большой шаг на пути к конечной цели. Более того, каждый из них может содержать в себе несколько под-шагов или даже различных вариантов одного и того же действия.&lt;/p>
&lt;p>Эти под-шаги или варианты, в данном методе называются &lt;strong>ЗАДАЧАМИ&lt;/strong> и отображаются в вертикальной оси, снизу от &lt;strong>КАРКАСА&lt;/strong>, с помощью стикеров другого цвета.&lt;/p>
&lt;p>Каждая &lt;strong>ЗАДАЧА&lt;/strong> относится к своему элементу &lt;strong>КАРКАСА&lt;/strong>, и описывает какое-то небольшое действие, целью которого является как раз таки, элемент &lt;strong>КАРКАСА&lt;/strong>. Если совсем просто, стикеры с задачами, размещаются под оранжевыми стикерами, к которым они имеют отношение. Каждый из стикеров-задач, является &lt;strong>ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИЕЙ&lt;/strong>, которая может быть передана разработчику.&lt;/p>
&lt;p>В случае с моей картой, стикеры-задачи могут выглядеть так:&lt;/p>
&lt;p>&lt;img src="/images/user-story-mapping/4.png" alt="user-story-mapping-task">&lt;/p>
&lt;p>Есть один простой трюк, который поможет описывать задачи так, чтобы:&lt;/p>
&lt;ul>
&lt;li>все они имели схожую смысловую структуру&lt;/li>
&lt;li>и, чтобы все участники моделирования, предельно точно понимали что и зачем нужно делать.
Именно из &lt;strong>ЗАДАЧ&lt;/strong>, в последствии будут созданы тикеты для разработчика.&lt;/li>
&lt;/ul>
&lt;p>Итак, трюк следующий - помните схему, по которой составляются &lt;strong>ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ&lt;/strong>:
&lt;code>As a [user], I want [something], So that [achieve some benefit]&lt;/code>
А теперь немного изменим её, заменив общие термины на элементы карты:&lt;/p>
&lt;pre>&lt;code>As a [user],
I want [task],
So that [backbone element]
&lt;/code>&lt;/pre>&lt;p>Моя схема написана на русском, так что, давайте, следуя этой схеме, попробуем составить несколько историй для разработчика:&lt;/p>
&lt;pre>&lt;code>1) Как клиент онлайн магазина, Я хочу использовать строку поиска, Чтобы найти нужный товар
2) Как клиент онлайн магазина, Я хочу использовать номер телефона, Чтобы залогиниться в системе
3) Как клиент онлайн магазина, Я хочу просмотреть описание товара, Чтобы посмотреть информацию о товаре
&lt;/code>&lt;/pre>&lt;p>Каждая из &lt;strong>ЗАДАЧ&lt;/strong>, в подобном написании, представляет из себя &lt;strong>ПОЛЬЗОВАТЕЛЬСКУЮ ИСТОРИЮ&lt;/strong>. В таком случае, каждый из оранжевых стикеров - представляет из себя Epic (то есть, большую задачу, которая состоит из ряда историй). Если уж совсем точно, то - оранжевые тикеты, это Epic’и в JIRA, тикеты-задачи - это User Story в JIRA. Каждая из User Story в JIRA, затем может быть разбита на несколько тикетов, в рамках которых разработчик реализует те или иные части фичи.&lt;/p>
&lt;h4 id="планирование">Планирование&lt;/h4>
&lt;p>Пришло время поговорить о последнем элементе &lt;strong>КАРТЫ ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong>, а именно о планировании.&lt;/p>
&lt;p>Если горизонтальная плоскость отображает шкалу времени, то вертикальная в данном методе, отображает приоритет. Чем выше &lt;strong>ЗАДАЧА&lt;/strong> в колонке, тем выше и её приоритет и, соответсвенно, она быстрее будет выполнена разработчиком.&lt;/p>
&lt;p>Есть два способа планирования в данном методе. Блок с &lt;strong>ЗАДАЧАМИ&lt;/strong> может быть поделён, с помощью горизонтальных линий на:&lt;/p>
&lt;ul>
&lt;li>важность или&lt;/li>
&lt;li>релизы&lt;/li>
&lt;/ul>
&lt;p>В случае с важностью, обычно используют три уровня: Must, Should, Could. Первый означает первоочерёдную ценность задач и означает, что они обязаны быть выполнены. Второй - что задачи важны и хорошо бы их выполнить. Третий - необязательны и могут быть не выполнены. Пример деления по важности выглядит следующим образом:&lt;/p>
&lt;p>&lt;img src="/images/user-story-mapping/5.png" alt="user-story-mapping-important">&lt;/p>
&lt;p>Как можно увидеть на скриншоте выше, мы просто разделили набор &lt;strong>ЗАДАЧ&lt;/strong> на блоки, относительно их важности.&lt;/p>
&lt;p>Второй способ, вместо важности - разделение на релизы. Выглядит следующим образом:&lt;/p>
&lt;p>&lt;img src="/images/user-story-mapping/6.png" alt="user-story-mapping-releases">&lt;/p>
&lt;p>Как можно заметить, выглядит это примерно так же, как и вариант выше, однако, насчёт привязки к номеру версии software решения, мы можем планировать &lt;strong>ПОЛЬЗОВАТЕЛЬСКИЕ ИСТОРИИ&lt;/strong> к выпуску в определённых версиях нашего софта.&lt;/p>
&lt;h3 id="процесс-моделирования">Процесс моделирования&lt;/h3>
&lt;p>В заключение, расскажу о том как, по мнению автора методологии, должен проходить процесс моделирования карт.&lt;/p>
&lt;p>Прежде всего, подобные карты создаются не одним человеком, а группой людей, включающей себя бизнес-ориентированных людей (Product Owner’а например), заинтересованных в фиче людей и разработчиков. Моделирование карты происходит в формате воркшопа, то есть - живого общения с обсуждениями и разноцветными стикерами на флипчартах и стенах.&lt;/p>
&lt;p>Основных шагов в ходе воркшопа пять:&lt;/p>
&lt;ol>
&lt;li>Определение скоупа. На данном этапе все участники сессии моделирования карты должны иметь единое понимание того, о чём будет идти речь. Пользователи и фичи, для которых будет производиться моделирование, должны быть оговорены заранее.&lt;/li>
&lt;li>Создание большой картины. На этом этапе накидываются основные идеи о составе истории. Происходит первоначальное создание каркаса фичи.&lt;/li>
&lt;li>Детализация. На данном этапе через коллективное обсуждение элементы каркаса разбиваются на более мелкие задачи. Пересматриваются элементы каркаса, меняются местами, добавляются новые, удаляются ненужные, выделяются активности.&lt;/li>
&lt;li>Разделение на релизы. На этом этапе задачи группируются на релизы. Каждый релиз фактически представляет из себя небольшой MVP. Каждый релиз должен иметь описание ценности, которую он доставит и описание метрик, с помощью которых можно будет замерить достижение цели релиза.&lt;/li>
&lt;li>Стратегия разработки и релизов. На этом этапе уже планируются задачи в разработку. Если нужно, карта актуализируется ещё. Цель этого этапа связать планирование на карте непосредственно с разработкой фичи.&lt;/li>
&lt;/ol>
&lt;h3 id="словарь-терминов">Словарь терминов&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>КАРТА ПОЛЬЗОВАТЕЛЬСКИХ ИСТОРИЙ&lt;/strong> - она же User Story Mapping; метод визуального описания и планирования задач.&lt;/li>
&lt;li>&lt;strong>ПОЛЬЗОВАТЕЛЬСКАЯ ИСТОРИЯ&lt;/strong> - она же User Story; это способ описания взаимодействия пользователя с software системой в формате
нарративного повествования.&lt;/li>
&lt;li>&lt;strong>КАРКАС&lt;/strong> - он же Backbone; основной набор шагов &lt;strong>ПОЛЬЗОВАТЕЛЬСКОЙ ИСТОРИИ&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>АКТИВНОСТИ&lt;/strong> - это группа задач, имеющих схожие цели.&lt;/li>
&lt;/ul>
&lt;h3 id="дополнительные-материалы">Дополнительные материалы&lt;/h3>
&lt;ul>
&lt;li>[1] &lt;a href="https://www.jpattonassociates.com/wp-content/uploads/2015/03/story_mapping.pdf">https://www.jpattonassociates.com/wp-content/uploads/2015/03/story_mapping.pdf&lt;/a> Отличный pdf документ-памятка по рассматриваему сегодня методу&lt;/li>
&lt;li>[2] &lt;a href="https://www.ozon.ru/product/polzovatelskie-istorii-iskusstvo-gibkoy-razrabotki-po-patton-dzheff-218989010/?utm_campaign=productpage_link&amp;amp;utm_medium=share_button&amp;amp;utm_source=smm">Книга «Пользовательские истории. Искусство гибкой разработки ПО» Паттон Джефф – купить книгу ISBN 978-5-496-02931-5 с быстрой доставкой в интернет-магазине OZON&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Уровни детализации Use Case'ов</title><link>/ru/posts/use-case-goal-levels/</link><pubDate>Tue, 19 Oct 2021 10:36:26 +0400</pubDate><guid>/ru/posts/use-case-goal-levels/</guid><description>Введение Для того, чтобы разобраться с темой, нам понадобятся два понятия:
СЦЕНАРИЙ - это последовательность шагов, совершаемых в определённых условиях, с целью достижения определённой цели, и, оканчивающаяся результатом, который напрямую связан с целью. Эта последовательность начинается с действия, которое является триггером (причиной для начала), и продолжается до тех пор, пока не будет достигнута или провалена конечная цель.
ПРЕЦЕДЕНТ - это набор сценариев взаимодействия между системой и актёрами; отображает как именно цель основного актёра может быть достигнута или провалена.</description><content>&lt;h3 id="введение">Введение&lt;/h3>
&lt;p>Для того, чтобы разобраться с темой, нам понадобятся два понятия:&lt;/p>
&lt;p>&lt;strong>СЦЕНАРИЙ&lt;/strong> - это &lt;strong>последовательность шагов&lt;/strong>, совершаемых в определённых условиях, с целью достижения определённой цели, и, оканчивающаяся результатом, который напрямую связан с целью. Эта последовательность начинается с действия, которое является триггером (причиной для начала), и продолжается до тех пор, пока не будет достигнута или провалена конечная цель.&lt;/p>
&lt;p>&lt;strong>ПРЕЦЕДЕНТ&lt;/strong> - это &lt;strong>набор сценариев&lt;/strong> взаимодействия между системой и актёрами; отображает как именно цель основного актёра может быть достигнута или провалена. Например, прецедент оформления возмещения страховой выплаты в результате происшествия, будет включать в себя оба сценария - «успешная выплата» и «выплата невозможна из-за нарушения правил».&lt;/p>
&lt;p>Если быть совсем точным, то в состав одного ПРЕЦЕДЕНТА, могут войти один и более СЦЕНАРИЕВ.&lt;/p>
&lt;p>СЦЕНАРИИ, в свою очередь, могут быть двух видов:&lt;/p>
&lt;ul>
&lt;li>Основными и&lt;/li>
&lt;li>Альтернативными&lt;/li>
&lt;/ul>
&lt;p>Основной СЦЕНАРИЙ - это сценарий, описывающий успешное достижение конечной цели главным актёром.&lt;/p>
&lt;p>Альтернативный СЦЕНАРИЙ - это сценарий, описывающий безуспешное достижение конечной цели главынм актёром, или же последовательность шагов, позволяющую достичь своей цели, после её провала.&lt;/p>
&lt;p>&lt;img src="/images/use-case-goal-levels/1.png" alt="use-case-mind-map">&lt;/p>
&lt;h4 id="примеры">Примеры&lt;/h4>
&lt;p>Скорее всего, описание Вам покажется неясным. Особенно, описание Альтернативного СЦЕНАРИЯ, однако, всё встанет на свои места, как только мы разберёмся с примером.&lt;/p>
&lt;p>Представьте, что мы составляем ПРЕЦЕДЕНТ, в котором Клиент (основной актёр) резервирует столики в системе обслуживания ресторана. Примером &lt;strong>основного СЦЕНАРИЯ&lt;/strong>, в таком случае может быть следующий сценарий:&lt;/p>
&lt;ol>
&lt;li>Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время&lt;/li>
&lt;li>Администратор проверяет наличие столика и подтверждает резерв&lt;/li>
&lt;/ol>
&lt;p>В этом случае, цель пользователя достигнута полностью - клиент получил столик в распоряжение в оговорённое время.&lt;/p>
&lt;p>&lt;strong>Альтернативный СЦЕНАРИЙ&lt;/strong>, в котором &lt;strong>цель&lt;/strong> основного актёра будет &lt;strong>провалена&lt;/strong>, может выглядеть следующим образом:&lt;/p>
&lt;ol>
&lt;li>Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время&lt;/li>
&lt;li>Администратор проверяет наличие столика и сообщает Клиенту о том, что в наличии свободного столика на оговорённую дату не имеется&lt;/li>
&lt;/ol>
&lt;p>Ну и наконец, &lt;strong>альтернативный СЦЕНАРИЙ&lt;/strong>, в котором &lt;strong>цель&lt;/strong> основного актёра будет &lt;strong>достигнута после&lt;/strong> её первоначального &lt;strong>провала&lt;/strong> будет выглядеть так:&lt;/p>
&lt;ol>
&lt;li>Клиент звонит в ресторан и просит зарезервировать столик на двоих на конкретную дату и время&lt;/li>
&lt;li>Администратор проверяет наличие столика и сообщает Клиенту о том, что в наличии свободного столика на оговорённую дату не имеется&lt;/li>
&lt;li>Администратор проверяет наличие столика на время ближайшее к оговорённому ранее и предлагает эту дату и время Клиенту&lt;/li>
&lt;li>Клиент подтверждает своё согласие на новую дату и время&lt;/li>
&lt;li>Администратор подтверждает резерв&lt;/li>
&lt;/ol>
&lt;h3 id="уровни-детализации">Уровни детализации&lt;/h3>
&lt;p>В своей работе под названием &amp;ldquo;Structuring Use cases with goals&amp;rdquo;, Алистер Кокбёрн, вводит понятие уровня моря, как &amp;ldquo;золотое сечение&amp;rdquo; степени детализации ПРЕЦЕДЕНТА и СЦЕНАРИЯ. Переводится это буквально - sea level (на следующем изображении, он подписан как &amp;ldquo;User Goal Level&amp;rdquo;).&lt;/p>
&lt;p>&lt;img src="/images/use-case-goal-levels/2.png" alt="use-case-granularity">&lt;/p>
&lt;p>Если внимательно посмотреть на изображение выше, можно увидеть, три больших уровня. На двух из них, существуют подуровни. Перечислим их:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Summary Level&lt;/strong> - можно перевести как &amp;ldquo;Уровень обобщения&amp;rdquo;. Он имеет два подуровня:
&lt;ul>
&lt;li>Cloud Level - буквально - &amp;ldquo;Уровень небес&amp;rdquo;&lt;/li>
&lt;li>Kite Level - &amp;ldquo;Уровень кайта&amp;rdquo;. Аналогии с предметами из жизни в данной модели приведены неспроста. Запущенный в небо кайт, летает ниже уровня облаков.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Sea Level&lt;/strong> (User Goal Level) - &amp;ldquo;Уровень моря&amp;rdquo;.&lt;/li>
&lt;li>&lt;strong>Subfunctions Level&lt;/strong>
&lt;ul>
&lt;li>Fish / Indigo Level&lt;/li>
&lt;li>Clam / Black Level&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Давайте поговорим о каждом из них.&lt;/p>
&lt;h4 id="summary-level">Summary Level&lt;/h4>
&lt;p>Summary Level или Уровень обобщения - это уровень на котором процессы видны в контексте их жизненного цикла. Что это значит, это значит что уровень деталей настолько мал, что мы можем изображать процесс, который в жизни занимает многие дни и даже годы. Каждый шаг на данном уровне имеют свою уникальную конечную цель и может быть представлен в деталях на Уровне моря.&lt;/p>
&lt;p>Кокбёрн выделяет два подуровня на Уровне обобщения:&lt;/p>
&lt;h5 id="cloud-level">Cloud Level&lt;/h5>
&lt;p>Уровень небес отображает процессы с наименьшим количеством деталей. ПРЕЦЕДЕНТОВ, описываемых на данном уровне может быть крайне мало, буквально, 5-6 на всю организацию. Примерами могут быть: реклама товаров, продажа товаров потребителям, управление ресурсами и т.д.&lt;/p>
&lt;h5 id="kite-level">Kite Level&lt;/h5>
&lt;p>Уровень кайта показывает обобщённые ПРЕЦЕДЕНТЫ. Сами же ПРЕЦЕДЕНТЫ на этом уровне изображаются на уровне департаментов, но продолжают отображать обобщённые цели. Примерами могут быть: регистрация пассажира на рейс, оформление билета на рейс.&lt;/p>
&lt;h4 id="sea-level-user-goal-level">Sea Level (User Goal Level)&lt;/h4>
&lt;p>На Уровне моря бизнес-процессы описываются уже более детализированно, чем на уровнях выше. Сам Кокбёрн рекомендует задавать следующие вопросы при разработке ПРЕЦЕДЕНТОВ и их СЦЕНАРИЕВ с этим уровнем детализации - &amp;ldquo;Может ли основной актёр уйти удовлетворённым после выполнения этого процесса? Достиг ли основной актёр своей конечной цели?&amp;rdquo;. Примерами могут быть: добавление товара в корзину, оформление заказа и т.д.&lt;/p>
&lt;p>Всё, что проектируется с уровнем детализации ниже Уровня моря скорее относится к системному дизайну, нежели к бизнес проектированию.&lt;/p>
&lt;h4 id="subfunctions-level">Subfunctions Level&lt;/h4>
&lt;p>Ниже Уровня моря лежат мелкие детали. Зачастую, люди из бизнеса не слишком заинтересованы в подобной детализации процессов, однако, людям из разработки подобный уровень детализации позволяет получить больше информации о технических аспектах реализации процесса.&lt;/p>
&lt;p>Кокбёрн выделяет следующие два под уровня:&lt;/p>
&lt;h5 id="fish--indigo-level">Fish / Indigo Level&lt;/h5>
&lt;p>Примерами могут быть: поиск кода аэропорта определённого города, отображение списка клиентов, после ввода имени и т.д.&lt;/p>
&lt;h5 id="clam--black-level">Clam / Black Level&lt;/h5>
&lt;p>Это самый низкий уровень с наибольшим количеством деталей. Подобная детализация может оказаться излишней даже для людей из разработки. Примерами могут быть: валидация введённых в поле данных, добавление нового поля в форму и т.д.&lt;/p>
&lt;h3 id="пример-с-картой">Пример с картой&lt;/h3>
&lt;p>Нужны ли все эти уровне в описании бизнес-процессов? Думаю, что нет. Однако, здорово иметь подобную свободу, ведь, каждый может выбрать способ описания ПРЕЦЕДЕНТОВ и СЦЕНАРИЕВ, подходящий конкретно ему.&lt;/p>
&lt;p>В любом случае, если после описания выше Вам всё ещё затруднительно разобраться, что это всё означает, я приведу пример с картой, который напрямую отображает некоторые уровни детализации.&lt;/p>
&lt;p>Итак, предположим, что у нас есть ПРЕЦЕДЕНТ - &amp;ldquo;Добраться из Самары в Москву&amp;rdquo;. Процесс перемещения из одного города в другой можно описать разными предложениями, с указанием разных деталей. Визуально, маршрут легко представить с помощью карты:&lt;/p>
&lt;p>&lt;img src="/images/use-case-goal-levels/3.jpg" alt="use-case-granularity-in-map">&lt;/p>
&lt;p>Как не сложно догадаться, все три картинки, отображают части маршрута от Самары до Москвы с разным удалением от уровня земли. Чем ближе к поверхности земли, тем больше деталей нам доступно.&lt;/p>
&lt;p>&lt;strong>Карта #1&lt;/strong> показывает весь маршрут с высоты Уровня небес. Глядя на маршрут с такой высоты мы можем описать его только фразами вида: &amp;ldquo;Выезжаем из Самарской области в сторону Пензы. Проезжаем Пензу и направляемся в сторону Рязани&amp;rdquo;. В жизни, перемещения на такие расстояния займут много часов.&lt;/p>
&lt;p>&lt;strong>Карта #2&lt;/strong> показывает участок маршрута на Уровне моря. Карта на этом уровне детализации содержит большее количество деталей. Маршрут на таком уровне детализации может быть описан примерно такими СЦЕНАРИЯМИ: &amp;ldquo;Выезжаем через северный выезд из города Самара и едем через посёлок Пребрежный в сторону Жигулёвска&amp;rdquo;. То есть, уровень детализации такой, что мы описываем перемещение между городами и сёлами в пределах одной области. Напомню, в случае с Уровнем небес, мы описывали перемещения между областями и большими городами.&lt;/p>
&lt;p>&lt;strong>Карта #3&lt;/strong> уже находится на Уровне Рыб (fish level), а значит содержит множество мелких деталей о маршруте. Если взглянуть на карту, можно увидеть маршрут с высокой детализацией - можно рассмотреть по каким именно улицам и дорогам нужно двигаться, где именно поворачивать, и т.д.&lt;/p>
&lt;h3 id="сферы-применения">Сферы применения&lt;/h3>
&lt;p>Напоследок, хочется порассуждать, а где же эти знания могут пригодиться?&lt;/p>
&lt;p>Действительно, разработчики в своей ежедневной практике практически не сталкиваются с разработкой ПРЕЦЕДЕНТОВ и бизнес требований, однако, всё же, это не значит, что навыки описания ПРЕЦЕДЕНТОВ с нужным уровнем детализации будут бесполезны.&lt;/p>
&lt;p>На мой взгляд, есть две сферы применения этих навыков в жизни разработчика:&lt;/p>
&lt;ol>
&lt;li>Это разработка и управление командой. В случае с разработкой, эти навыки позволяют правильно воспринимать требования их ПРЕЦЕДЕНТОВ, переданных в разработку. Сопоставляя конечную цель основного актёра и СЦЕНАРИИ, входящие в состав ПРЕЦЕДЕНТОВ, разработчик может как лучше понять детали будущей реализации системы, так и увидеть белые пятна в предложенных СЦЕНАРИЯХ (недостаток деталей).&lt;/li>
&lt;li>Это проектирование. Такие подходы к проектированию, как Domain Storytelling сильно завязаны на понятия СЦЕНАРИЯ и уровней детализации. Наличие навыка составления граммотных ПРЕЦЕДЕНТОВ и СЦЕНАРИЕВ играет ключевую роль в проектировании domain stories в подходе.&lt;/li>
&lt;/ol>
&lt;h3 id="словарь-терминов">Словарь терминов&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>СЦЕНАРИЙ&lt;/strong> - он же scenario, он же user story.&lt;/li>
&lt;li>&lt;strong>ПРЕЦЕДЕНТ&lt;/strong> - он же use case или сценарий использования.&lt;/li>
&lt;/ul>
&lt;h3 id="дополнительные-материалы">Дополнительные материалы&lt;/h3>
&lt;ul>
&lt;li>[1] Книга Алистера Кокбёрна &amp;ldquo;Writing Effective Use Cases&amp;rdquo; &lt;a href="https://www.ozon.ru/product/writing-effective-use-cases-1829617/?sh=jD1ziFN8">https://www.ozon.ru/product/writing-effective-use-cases-1829617/?sh=jD1ziFN8&lt;/a>&lt;/li>
&lt;li>[2] Методичка Алистера Кокбёрна &amp;ldquo;Structuring Use cases with goals&amp;rdquo; &lt;a href="https://www.researchgate.net/publication/2807676_Structuring_Use_cases_with_goals">https://www.researchgate.net/publication/2807676_Structuring_Use_cases_with_goals&lt;/a>&lt;/li>
&lt;li>[3] Статья &amp;ldquo;Use Case Modelling&amp;rdquo; &lt;a href="https://www.w3computing.com/systemsanalysis/use-case-modeling/">https://www.w3computing.com/systemsanalysis/use-case-modeling/&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Как проектировать REST API?</title><link>/ru/posts/design-rest-api/</link><pubDate>Sun, 03 Oct 2021 18:55:34 +0400</pubDate><guid>/ru/posts/design-rest-api/</guid><description>Изначально, это статью Я написал для своего блога на Medium [1]. Сюда переношу её почти без изменений. Что такое API? API или Application Programming Interface — это описание способа взаимодействия программ. Если быть точнее, это набор классов, интерфейсов, структур данных, которые объявлены программой. С помощью них можно заставить программу выполнять действия. Какие именно действия — описано как раз таки в API.
API’ев существует огромное множество. Например, сама Java даёт разработчику доступ к десяткам API — Core API, Concurrency API, Collection API и много много других.</description><content>&lt;pre>&lt;code>Изначально, это статью Я написал для своего блога на Medium [1].
Сюда переношу её почти без изменений.
&lt;/code>&lt;/pre>&lt;h1 id="что-такое-api">Что такое API?&lt;/h1>
&lt;p>&lt;strong>API или Application Programming Interface&lt;/strong> — это описание способа взаимодействия программ. Если быть точнее, это набор классов, интерфейсов, структур данных, которые объявлены программой. С помощью них можно заставить программу выполнять действия. Какие именно действия — описано как раз таки в API.&lt;/p>
&lt;p>&lt;strong>API’ев существует огромное множество&lt;/strong>. Например, сама Java даёт разработчику доступ к десяткам API — Core API, Concurrency API, Collection API и много много других. Сторонние фреймворки тоже предоставляют свои API — Hibernate API, JPA (Java Persistence API), RestEasy и другие.&lt;/p>
&lt;p>&lt;strong>У каждого API есть своя цель&lt;/strong>. API’и не делают просто так. Каждый API сродни пульту управления от телевизора. Он даёт возможность управлять программой. Например, программа для анализа использования дискового пространства может содержать API, который позволит получить статистику о файлах и занятом ими пространнстве; укажет на самый тяжёлый файл на диске и так далее. При этом каждое API не позволяет делать произвольные вещи. Все возможности API согласованы с его целью.&lt;/p>
&lt;p>&lt;strong>API’и не привязаны к конкретной технологии&lt;/strong>. Если программа написана на Java это не означает, что API ограничен этим языком программирования. Приложение может предоставлять API, не привязанное к конкретной технологии, на которой оно построено. Пример — REST API.&lt;/p>
&lt;h1 id="что-такое-rest-api">Что такое REST API?&lt;/h1>
&lt;p>REST или Representational State Transfer («передача состояния представления») это архитектурный подход, основанный на протоколе HTTP.&lt;/p>
&lt;h1 id="зачем-проектировать-rest-api">Зачем проектировать REST API?&lt;/h1>
&lt;p>&lt;strong>Построение программ — это игра в конструктор без жёстких правил&lt;/strong>. Победить в этой игре могут все. Но настоящее искусство программиста это написание таких программ, которые будут работать быстро, безотказно и легко расширяться. Поэтому, как и при стройке дома, важно знать заранее что и как будет построено, ибо цена ошибки на этапе проектирование ниже, чем цена ошибки в момент, когда дом уже готов.&lt;/p>
&lt;h1 id="предметно-ориентированное-проектирование-rest-api">Предметно-ориентированное проектирование REST API&lt;/h1>
&lt;p>&lt;strong>Техника, которой я сегодня поделюсь&lt;/strong> хорошо описана в книге издательства Manning — “The Design of Web APIs&amp;quot; [2]. Ссылку на книгу можно найти в конце статьи.&lt;/p>
&lt;p>&lt;strong>Небольшая вводная&lt;/strong>, прежде чем мы приступим к рассмотрению методики. Все идеи и советы ниже крайне ориентированы на практику. Это не теоретические знания, это живой метод проектирования REST API, поэтому и разбирать мы его будем на живом примере. Представьте, что Нам нужно спроектировать REST API для блог-сервиса. Конкретно, Мы отвечаем за работу с постами и их комментариями. На примере этого требования мы и разберёмся с методом.&lt;/p>
&lt;p>&lt;strong>Какие цели могут быть у такого API?&lt;/strong> Пожалуй их будет несколько:&lt;/p>
&lt;ul>
&lt;li>Прочитать имеющиеся посты. Должен быть способ получить список уже имеющихся постов.&lt;/li>
&lt;li>Изменение имеющегося поста. Что если в текст прокралась ошибка? Автор должен иметь возможность её поправить после написания и публикации поста.&lt;/li>
&lt;li>Создание нового поста. Как-то же пост попадает наш блогосервис.&lt;/li>
&lt;li>Удаление поста. Автор решил удалить свой устаревший пост или пост с идеями, в которые он больше не верит.&lt;/li>
&lt;li>Чтение комментариев к посту. Для краткости предположим что комментарии попадают в наш блогосервис каким-то иным способом, не через наше REST API. Однако, в нашем REST API мы хотим разрешить пользователям читать комментарии для имеющихся постов.&lt;/li>
&lt;/ul>
&lt;p>Эти цели мы транслируем в REST API.&lt;/p>
&lt;p>&lt;strong>Теперь разберёмся с основными правилами&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Цели транслируются в &lt;strong>ресурсы&lt;/strong> и &lt;strong>действия&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Ресурсы&lt;/strong> определяются путём в REST API, а &lt;strong>действия&lt;/strong> определяются методами HTTP&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Что такое ресурс?&lt;/strong> Ресурс это объект, представление, сущность, всё что угодно, что представляет данные в системе. В нашем блогосервисе ресурсов несколько — Пост и Комментарий.&lt;/p>
&lt;p>&lt;strong>Что такое действие?&lt;/strong> Действие это способ заставить наш блогосервис что-то сделать, например — отдать список имеющихся постов, создать новый и так далее. Действия определяются методами HTTP протокола, как уже было сказано выше. Таких действий несколько, но нас интересуют стандартные: GET, POST, PUT, DELETE.&lt;/p>
&lt;p>&lt;strong>Перейдём к самому проектированию&lt;/strong>. Разберём его по шагам:&lt;/p>
&lt;ul>
&lt;li>Перво-наперво нужно определить все ресурсы и под-ресурсы, с которыми наше API должно работать. В нашем случае это &lt;strong>Пост&lt;/strong> и &lt;strong>Комментарий&lt;/strong>.&lt;/li>
&lt;li>Далее, нужно определить набор действий, которые наше API позволяет совершать над ресурсами. Для нас это:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>GET Пост — для получения списка имеющихся постов&lt;/li>
&lt;li>POST Пост — для создания нового поста&lt;/li>
&lt;li>PUT Пост — для изменения имеющегося поста&lt;/li>
&lt;li>DELETE Пост — для удаления поста&lt;/li>
&lt;li>GET Комментарий — для получения списка комментариев поста&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Определим набор параметров для действий, которые мы спроектировали выше:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>Операция получения постов GET — может быть вызвана как без параметров, что приведёт к чтению всех имеющихся постов, так и с идентификатором конкретного поста для получения выбранного поста&lt;/li>
&lt;li>Операция создания поста POST подразумевает, что в неё будет передана информация о посте, который необходимо создать&lt;/li>
&lt;li>PUT требует двух параметров — идентификатора поста, который мы будем изменять и сам пост, который заменит имеющийся в блогосервисе&lt;/li>
&lt;li>DELETE требует идентификатора поста, который необходимо удалить&lt;/li>
&lt;li>Операция получения комментариев GET требует идентификатора поста, потому что мы хотим получить список комментариев к определённому посту&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Прервёмся на секунду&lt;/strong>. Мы провели большую подготовительную работу для сбора данных о нашем будущем API. Теперь мы знаем как конкретно и с чем конкретно наше API будет работать. Но эту информацию стоит дополнить и на следующем шаге мы займёмся именно этим.&lt;/p>
&lt;p>На какие ещё моменты нам стоит обратить внимание? Их несколько. Нужно ответить на следующие вопросы:&lt;/p>
&lt;ul>
&lt;li>Кто будет вызывать операции API?&lt;/li>
&lt;li>Что и как будет делать этот кто-то с нашим API?&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Небольшая ремарка&lt;/strong> — структура статьи на Medium не позволяет создать таблицу, хотя дальнейшую работу по проектированию нашего REST API я рекомендую проводить именно с таблицами. Поэтому дальше — мы в текстовом виде разберём что нам нужно делать, но я подразумеваю, что все моменты которые мы оговорим будут внесены в специальную таблицу.&lt;/p>
&lt;p>&lt;strong>Наша таблица проектирования — наш помощник&lt;/strong>. Список её колонок следующий:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Кто&lt;/strong> — тут могут быть роли пользователей, которые будут работать с нашим API&lt;/li>
&lt;li>&lt;strong>Что&lt;/strong> — имеется ввиду что делает пользователь с нашим API. Его ожидания&lt;/li>
&lt;li>&lt;strong>Как&lt;/strong> — опять же, как наш пользователь достигает своей цели&lt;/li>
&lt;li>&lt;strong>Входные данные&lt;/strong> — информацию, которую необходимо передать нашему API, для того, чтобы оно помогло пользователю достигнуть цели&lt;/li>
&lt;li>&lt;strong>Выходные данные&lt;/strong> — информация, которую вернёт наш API в результате работы метода&lt;/li>
&lt;li>&lt;strong>Цель&lt;/strong> — описывает явно смысл конкретной операции нашего API&lt;/li>
&lt;li>&lt;strong>HTTP метод&lt;/strong> — указание на HTTP метод, который описывает действие нашего пользователя&lt;/li>
&lt;li>&lt;strong>URI&lt;/strong> — путь по которому данная операция нашего API доступна клиентам&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/images/design-rest-api/1.png" alt="design-rest-api-table-1">&lt;/p>
&lt;p>&lt;strong>Всё что нам осталось сделать&lt;/strong>, это на основе информации, которую мы проговорили выше &lt;strong>заполнить эту табличку&lt;/strong>. Попробуем сделать это для операции получения постов:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/2.png" alt="design-rest-api-table-2">&lt;/p>
&lt;p>&lt;strong>Разберём подробнее&lt;/strong>. Раз уж мы работаем с постами, то кто-то их должен писать. Это будет Автор. Автор может получить доступ ко всем своим постам, поэтому для операции чтения постов нам не требуется никаких входных данных. Реализация самого API может установить текущего пользователя системы и определить авторство постов. На выходе же мы получим список постов, которые были написаны автором (или текущем залогиненным пользователем). Операция получения данных описывается в HTTP протоколе методом GET, а URI в конце, может иметь произвольную структуру, но общепринято в хвосте URL путь писать с указанием ресурса с которым в данном API мы работаем во множественном числе. В нашем случае это &lt;code>…/posts&lt;/code>.&lt;/p>
&lt;p>&lt;strong>По мере заполнения таблицы, всегда задаём себе вопросы&lt;/strong> — откуда берутся ресурсы, кто с ними работает и так далее. Чем шире посмотреть на имеющиеся данные, тем больше возможных кейсов можно идентифицировать на этапе проектирования. Простой пример — мы спроектировали операцию получения авторских постов. Но кто эти посты добавляет в систему? Очевидно, что авторы. Спроектируем и это:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/3.png" alt="design-rest-api-table-3">&lt;/p>
&lt;p>Пользуясь этим подходом &lt;strong>спроектируем оставшиеся операции&lt;/strong>:&lt;/p>
&lt;p>&lt;img src="/images/design-rest-api/4.png" alt="design-rest-api-table-4">&lt;/p>
&lt;p>&lt;strong>Обратите внимание на последнюю строку&lt;/strong>. Мы уже коснулись темы подресурсов выше. В таблице на картинке выше Вы можете заметить как выглядит URI для доступа к комментариям поста. В пути сначала пишется родительский ресурс, а потом уже указание на подресурс: &lt;code>/api/[resource]/{id}/[sub-resource]&lt;/code>. Это общепринятая практика и подобное построение пути даёт возможность пользователям Вашего API сразу понять какие ресурсы зависят от других.&lt;/p>
&lt;p>&lt;strong>В заключение, хочется задать вопрос — Подходит ли спроектированное нами API на все случаи жизни? Конечно же — нет&lt;/strong>. Если Вы присмотритесь к таблице внимательнее, станет ясно, что это API предназначено исключительно для Авторов постов. Автор может читать только свои посты. А вот пользователи блогосервиса должны получать доступ ко всем постам всех авторов. Такие вот моменты становятся видны, если на этапе проектирования каждой из операции задавать вопросы о том, кто будет пользоваться ими и в каких случаях.&lt;/p>
&lt;p>&lt;strong>Надеюсь эта статья поможет Вам&lt;/strong> подступиться к такой огромной теме как REST API’и и направит Вас в моменты, когда придётся проектировать собственное API.&lt;/p>
&lt;h1 id="полезные-ссылки">Полезные ссылки&lt;/h1>
&lt;ul>
&lt;li>[1] Мой старый &lt;a href="https://anver-bogatov.medium.com/%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-rest-api-86b2d6737401">блог на Medium&lt;/a>&lt;/li>
&lt;li>[2] Книга &amp;ldquo;The Design of Web APIs&amp;rdquo; &lt;a href="https://www.manning.com/books/the-design-of-web-apis">на Manning&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>